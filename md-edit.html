<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDEdit</title>

    <link rel="icon" type="image/png" href="resources/icon/md-edit-icon.png">

    
    <!-- MathLive Library -->
    <script src="https://unpkg.com/mathlive"></script>
    
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <!-- Mermaid JS (Flowcharts) -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

    <!-- Chart.js (Charts) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Desmos API -->
    <script src="https://www.desmos.com/api/v1.9/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Momo+Trust+Sans:wght@200..800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">

    <style>
        :root {
            --glass-bg: rgba(255, 255, 255, 0.85);
            --glass-border: rgba(255, 255, 255, 0.5);
            --glass-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            --blur: blur(20px);
            
            --primary: #007AFF; 
            --primary-glow: rgba(0, 122, 255, 0.3);
            --chem: #34C759; 
            --danger: #FF3B30; 
            --text: #1d1d1f;
            --bg-app: #f5f5f7;
            
            --transition: all 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        /* --- Global Reset & Font Fixes --- */
        * { box-sizing: border-box; }
        
        input, button, select, textarea { font-family: inherit; }

        body {
            background-color: var(--bg-app);
            background-image: radial-gradient(circle at 50% -20%, #e0e7ff 0%, #f5f5f7 40%);
            font-family: 'Momo Trust Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-y: scroll;
            padding-bottom: 100px;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.15); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.25); }
        ::selection {
            background-color: rgba(0, 122, 255, 0.25); /* Very light blue */
            color: inherit; /* Keeps syntax highlighting/text color visible */
        }

        ::-moz-selection {
            background-color: rgba(0, 122, 255, 0.25);
            color: inherit;
        }

        body.dark-mode ::selection {
            background-color: rgba(64, 156, 255, 0.35); 
            color: #fff; /* In dark mode, white text is usually safer for contrast */
        }

        body.dark-mode ::-moz-selection {
            background-color: rgba(64, 156, 255, 0.35);
            color: #fff;
        }

        math-virtual-keyboard { --keyboard-zindex: 3000; }
        math-field.chem-field { --math-font-style: normal; }

        /* --- Header & Title Area (From 1.html) --- */
        .header-area {
            width: 100%;
            max-width: 850px;
            margin-top: 60px;
            margin-bottom: 20px;
            text-align: center;
        }

        #docTitle {
            background: transparent; border: none; font-size: 2.8rem; font-weight: 700;
            color: var(--text); text-align: center; width: 100%;
            padding: 10px; outline: none; opacity: 0.9;
            transition: var(--transition);
        }
        #docTitle:hover, #docTitle:focus { opacity: 1; }

       #docTitle::placeholder { color: #ccc; }

        /* --- Sticky Toolbar Wrapper (From 1.html) --- */
        .sticky-wrapper {
            position: sticky;
            top: 20px;
            z-index: 2000;
            display: flex;
            justify-content: center;
            width: 100%;
            pointer-events: none;
            margin-bottom: 10px;
        }

        .toolbar-container {
            pointer-events: auto;
            background: var(--glass-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border-radius: 999px; /* Reduced radius slightly for boxier look */
            box-shadow: var(--glass-shadow);
            border: 1px solid var(--glass-border);
            padding: 8px 35px;
            transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1),
                        padding 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
            
            /* FIX: Allow rows to stretch so we can align them differently */
            align-items: stretch; 
            gap: 4px;
            max-width: fit-content;
        }

        .sticky-wrapper.is-stuck .toolbar-container {
           box-shadow: 0 15px 50px rgba(0,0,0,0.15);
           background: rgba(255, 255, 255, 0.95);
            padding: 10px 35px;
            transform: translateY(5px);
        }

        .toolbar-row {
            display: flex;
            align-items: center;
            gap: 6px;
            width: 100%;
            /* FIX: Top row stays centered */
            justify-content: center; 
        }

        /* FIX: Secondary Row Styling */
        .toolbar-row.secondary {
           border-top: 1px solid rgba(0,0,0,0.05);
            padding-top: 4px;
            margin-top: 2px;
            
            /* Align to the left */
            justify-content: flex-start;
            
            /* Make elements smaller */
            transform: scale(0.8);
            transform-origin: left top;
            /* Compensate width because of scale down */
            width: 111%; 
            margin-bottom: -10px; /* Remove extra space caused by scale */
        }

        /* Mini Title (Hidden by default) */
        .mini-title-wrapper {
            max-width: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-width 0.6s cubic-bezier(0.2, 0.8, 0.2, 1), 
                        opacity 0.4s ease-in,
                        margin-right 0.4s ease,
                        padding-right 0.4s ease;
            margin-right: 0;
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .sticky-wrapper.is-stuck .mini-title-wrapper {
            width: auto;
            opacity: 1;
            margin-right: 12px;
            padding-right: 12px;
            border-right: 1px solid rgba(0,0,0,0.1);
            max-width: 200px;
        }

        #miniTitleInput {
            background: transparent; border: none; font-weight: 700;
            font-size: 1.1rem; color: #333; outline: none; width: 100%;
            text-overflow: ellipsis;
        }

        /* --- Buttons & Tools --- */
        .tool-btn {
            background: transparent; border: none; cursor: pointer;
            width: 36px; height: 36px; border-radius: 50%;
            color: #555; font-size: 1.2rem; display: flex;
            align-items: center; justify-content: center;
            transition: var(--transition); position: relative;
        }
        .tool-btn:hover { background-color: rgba(0, 0, 0, 0.05); color: var(--text); }
        .tool-btn:active { transform: scale(0.92); }
        
        .tool-btn.active-state { background: var(--primary); color: white; box-shadow: 0 4px 12px var(--primary-glow); }
        .btn-math:hover { color: var(--primary); background: rgba(0, 122, 255, 0.1); }
        .btn-chem:hover { color: var(--chem); background: rgba(52, 199, 89, 0.1); }

        .btn-text {
            width: auto; padding: 2px 10px; /* Reduced Padding */
            border-radius: 20px; 
            font-size: 0.8rem; /* Slightly smaller font */
            font-weight: 600; color: #444;
            height: 28px; /* Reduced Height */
            cursor: pointer; border: none; background: transparent;
            transition: var(--transition);
            display: flex; align-items: center;
        }
        .btn-text:hover { background: rgba(0,0,0,0.05); color: var(--primary); }

        .divider { width: 1px; height: 18px; background: rgba(0,0,0,0.1); margin: 0 2px; }

        /* --- Dropdowns (From 1.html) --- */
        .dropdown-wrapper { position: relative; display: flex; align-items: center; }
        .dropdown-content {
            position: absolute; top: 100%; left: 50%; transform: translateX(-50%) scale(0.95);
            margin-top: 5px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(15px);
            border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            border: 1px solid rgba(0,0,0,0.05); padding: 6px;
            display: flex; flex-direction: column; gap: 5px;
            min-width: 160px; opacity: 0; visibility: hidden;
            transition: 0.2s; z-index: 2500;
        }
        
        /* Bridge for hover */
        .dropdown-wrapper::after { content:''; position: absolute; top: 100%; left:0; width:100%; height:2px; }
        .dropdown-wrapper:hover .dropdown-content, .dropdown-content:hover { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(0) scale(1); pointer-events: auto; }

        .dropdown-item label {
            cursor: pointer;
        }
        .dropdown-item {
            padding: 8px 12px; border-radius: 8px; cursor: pointer; 
            font-size: 0.9rem; color: #333; display: flex; align-items: center; gap: 10px;
            transition: 0.2s; background: transparent; border: none; width: 100%; text-align: left;
        }
        .dropdown-item:hover { background: var(--primary); color: white; }
        .dropdown-item i { font-size: 1.1rem; width: 20px; text-align: center; }

        /* Tooltips */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip); position: absolute; top: 110%; left: 50%; transform: translateX(-50%);
            background: rgba(20, 20, 20, 0.85); color: white; font-size: 11px; padding: 4px 8px;
            border-radius: 4px; white-space: nowrap; pointer-events: none; opacity: 0;
            animation: tooltipSlide 0.2s forwards; z-index: 3000;
        }
        @keyframes tooltipSlide { from { opacity:0; transform:translateX(-50%) translateY(-5px); } to { opacity:1; transform:translateX(-50%) translateY(0); } }

        /* --- Editor (From editor.html with tweaks) --- */
        #editor {
            background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px);
            width: 100%; max-width: 850px; min-height: 1000px; border-radius: 8px; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.05); padding: 80px; box-sizing: border-box;
            outline: none; font-size: 17px; line-height: 1.7; margin-bottom: 50px;
            padding-bottom: 50px; /* Huge bottom padding so user can always scroll past content */
            cursor: text; /* Ensure it looks clickable */
            transition: box-shadow 0.3s;
        }
        #editor:focus { box-shadow: 0 12px 40px rgba(0,0,0,0.08); }
        #editor h1 { font-size: 2.2em; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.3em; margin-top: 1.5em; }
        #editor h2 { font-size: 1.6em; color: #333; margin-top: 1.5em; }
        #editor h3 { font-size: 1.3em; color: #555; margin-top: 1.2em; }
        #editor h4 { font-size: 1.2em; color: #666; margin-top: 1.2em; }
        #editor h5 { font-size: 1.1em; color: #777; margin-top: 1.2em; }
        #editor li { margin-bottom: 0.5em; }

        /* Wrappers for Block Elements */
        .quote-wrapper, .code-block-wrapper, .visual-block-wrapper, .block-container, details.markscheme {
            position: relative; display: block; margin: 1.5em 0;
            border-radius: 8px; border: 1px solid transparent; transition: var(--transition);
        }
        
        /* Specific Visual Styles */
        .quote-wrapper blockquote { border-left: 4px solid var(--primary); background: rgba(0, 122, 255, 0.04); margin: 0; padding: 16px 24px; color: #444; font-style: italic; border-radius: 4px; outline: none; }
        
        .code-wrapper { display: inline-block; vertical-align: baseline; margin: 0 2px; }
        .inline-code { font-family: 'Google Sans Code', monospace; background: #f0f2f5; color: #d63384; padding: 2px 6px; border-radius: 4px; font-size: 0.85em; border: 1px solid rgba(0,0,0,0.05); outline: none; }
        
        .code-block-wrapper pre { background: #252526; color: #d4d4d4; padding: 20px; border-radius: 8px; font-family: 'Google Sans Code', monospace; font-size: 0.9em; overflow-x: auto; margin: 0; outline: none; }
        
        #editor img { max-width: 100%; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }

        math-field { background: rgba(0,0,0,0.04); border-radius: 6px; padding: 2px 6px; transition: var(--transition); border: 1px solid transparent; min-width: 24px; }
        math-field:focus-within { background: white; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.25); transform: scale(1.05); z-index: 10; }
        math-field.chem-field { background: rgba(52, 199, 89, 0.1); color: #0c501e; font-style: normal !important; }
        
        .math-wrapper { display: inline-block; vertical-align: middle; margin: 0 2px; }
        .block-container { text-align: center; }
        .block-container math-field { padding: 15px 25px; font-size: 1.3em; background: white; box-shadow: inset 0 2px 4px rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.1); border-radius: 12px; display: inline-block; width: 100%; text-align: left; }

        .visual-block-wrapper::after { content: 'Double-click to edit'; display: block; font-size: 0.75rem; color: var(--primary); font-weight: 600; margin-top: 10px; text-align: center; opacity: 0; transition: 0.2s; transform: translateY(5px); }
        .visual-block-wrapper:hover::after { opacity: 1; transform: translateY(0); }

        details.markscheme {
            background: white; 
            border-radius: 12px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); 
            /* CHANGED FROM HIDDEN TO VISIBLE so buttons show */
            overflow: visible; 
            margin: 25px 0; 
            border: 1px solid rgba(0,0,0,0.08);
            position: relative;
        }
        details.markscheme summary { background: #fafafa; padding: 12px 20px; cursor: pointer; font-weight: 600; transition: 0.2s; color: #444; user-select: none; }
        .markscheme-content { padding: 20px; border-top: 1px solid rgba(0,0,0,0.05); }

        /* The Delete Button (Preserved from editor.html) */
        .btn-block-delete {
            position: absolute; top: -10px; right: -10px; width: 24px; height: 24px;
            background: #FF3B30; color: white; border-radius: 50%; border: 2px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); cursor: pointer; display: flex;
            align-items: center; justify-content: center; font-size: 14px; opacity: 0;
            transform: scale(0.8); transition: all 0.2s ease; z-index: 100;
        }
        .quote-wrapper:hover .btn-block-delete, .code-block-wrapper:hover .btn-block-delete, .visual-block-wrapper:hover .btn-block-delete, .block-container:hover .btn-block-delete, details.markscheme:hover .btn-block-delete { opacity: 1; transform: scale(1); pointer-events: auto; }
        .btn-block-delete:hover { transform: scale(1.1); background: #d70000; }

        /* --- FIXED MODAL ANIMATIONS --- */

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.2); backdrop-filter: blur(8px); z-index: 5000;
            display: flex; justify-content: center; align-items: center;
            cursor: default;
            
            /* Default State (Closed) */
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            
            /* CLOSE ANIMATION: Fade out opacity (0.3s), but WAIT 0.3s before snapping visibility to hidden */
            transition: opacity 0.3s ease, visibility 0s linear 0.3s; 
        }

        .modal-overlay.active {
            /* Active State (Open) */
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            
            /* OPEN ANIMATION: Fade in opacity, show visibility INSTANTLY */
            transition: opacity 0.3s ease, visibility 0s;
        }

        .modal {
            background: rgba(255, 255, 255, 0.95); padding: 30px;
            border-radius: 24px; box-shadow: 0 20px 60px rgba(0,0,0,0.2);
            border: 1px solid rgba(255,255,255,0.8); display: flex; flex-direction: column; gap: 15px;
            
            /* Default State (Closed): Slightly smaller and lower to create a "drop" effect */
            transform: scale(0.95) translateY(10px);
            opacity: 0;
            
            /* Smooth physics-based curve */
            transition: transform 0.3s cubic-bezier(0.19, 1, 0.22, 1),
                        opacity 0.3s ease;
        }

        body.modal-open {
            overflow: hidden !important;
            /* Optional: prevent "layout shift" when scrollbar disappears */
            padding-right: 8px; 
        }

        .modal-overlay.active .modal {
            /* Active State (Open): Full size, centered */
            transform: scale(1) translateY(0);
            opacity: 1;
        }
        .modal h3 { margin: 0; font-size: 1.2rem; text-align: center; color: #333; margin-bottom: 5px;}

        /* File List Styles (From 1.html) */
        #fileList { width: 500px; max-height: 400px; overflow-y: auto; }
        .file-item { cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 12px; border-bottom: 1px solid #eee; transition: 0.2s; }
        .file-item:hover { background: rgba(0,0,0,0.03); }
        .file-info { display: flex; flex-direction: column; }
        .file-name { font-weight: 600; font-size: 0.95rem; }
        .file-meta { font-size: 0.75rem; color: #888; }
        .file-actions { display: flex; gap: 8px; }

        /* Builder Layouts (Preserved from editor.html) */
        .modal.large-modal { width: 90vw; height: 85vh; padding: 0; overflow: hidden; max-width: 1200px; display:flex; flex-direction: row;}
        .builder-layout { display: flex; flex-direction: row; width: 100%; height: 100%; }
        .builder-layout.full-layout { flex-direction: column; padding: 20px; }
        .builder-panel { width: 320px; min-width: 320px; background: #fafafc; border-right: 1px solid rgba(0,0,0,0.1); padding: 20px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; flex-shrink: 0; }
        .preview-panel { flex: 1; padding: 30px; background: white; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; background-image: radial-gradient(#e5e7eb 1px, transparent 1px); background-size: 20px 20px; }
        
        /* Builder Inputs */
        .builder-section { background: white; padding: 12px; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.05); border: 1px solid rgba(0,0,0,0.06); }
        .builder-header { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; color: #888; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .builder-row { display: flex; gap: 6px; margin-bottom: 8px; align-items: center; width: 100%; }
        .builder-input, .builder-select { padding: 6px 10px; border: 1px solid #e0e0e0; border-radius: 8px; font-size: 0.85rem; min-width: 0; flex: 1; transition: 0.2s; }
        .builder-input:focus, .builder-select:focus { border-color: var(--primary); outline: none; box-shadow: 0 0 0 2px var(--primary-glow); }
        .btn-icon { background: #eee; border: none; width: 28px; height: 28px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: #555; transition: 0.2s; flex-shrink: 0; }
        .btn-icon:hover { background: #e0e0e0; color: black; }
        .btn-icon.delete:hover { background: #ffebeb; color: var(--danger); }
        .btn-add-item { width: 100%; padding: 8px; border: 1px dashed #ccc; background: transparent; border-radius: 8px; color: #666; font-size: 0.85rem; cursor: pointer; transition: 0.2s; font-weight: 500; }
        .btn-add-item:hover { border-color: var(--primary); color: var(--primary); background: rgba(0,122,255,0.03); }

        .glass-input { padding: 12px 16px; border-radius: 12px; border: 1px solid rgba(0,0,0,0.1); background: rgba(255,255,255,0.5); font-size: 1rem; outline: none; transition: 0.2s; width: 100%; }
        .glass-input:focus { background: white; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(0,122,255,0.1); }
        
        .file-upload-wrapper { position: relative; overflow: hidden; display: block; width: 100%; margin-top: 10px;}
        .btn-file-choice { border: 2px dashed rgba(0,0,0,0.1); border-radius: 12px; background: rgba(255,255,255,0.4); color: #555; padding: 20px; text-align: center; cursor: pointer; transition: 0.2s; font-weight: 500; display: flex; flex-direction: column; align-items: center; gap: 8px; }
        .btn-file-choice:hover { border-color: var(--primary); color: var(--primary); background: rgba(0,122,255,0.03); }
        #imgFileInput { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }

        .modal-actions { display: flex; justify-content: space-between; margin-top: 20px; gap: 10px; }
        .btn-glass { padding: 10px 24px; border-radius: 12px; font-weight: 600; cursor: pointer; border: none; transition: 0.2s; font-size: 0.95rem; }
        .btn-glass-cancel { background: #f2f2f7; color: #555; }
        .btn-glass-cancel:hover { background: #e5e5ea; }
        .btn-glass-insert { background: var(--primary); color: white; opacity: 0.5; pointer-events: none; }
        .btn-glass-insert.active { opacity: 1; pointer-events: auto; box-shadow: 0 4px 15px var(--primary-glow); }
        .btn-glass-insert.active:hover { transform: translateY(-1px); box-shadow: 0 6px 20px var(--primary-glow); }
        
        .chart-actions { position: absolute; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 100; }
        .chart-container-box { width: 100%; max-width: 700px; height: 100%; display: flex; justify-content: center; align-items: center; }
        #desmosContainer { width: 100%; height: 100%; border-radius: 12px; overflow: hidden; border: 1px solid #ccc; }
        #tempCalculator { position: absolute; top: 0; left: 0; width: 600px; height: 400px; opacity: 0; pointer-events: none; z-index: -100; }
        
        .mermaid svg, canvas { max-width: 100%; height: auto !important; display: block; }
        .mermaid-wrapper .mermaid { display: flex; justify-content: center; width: 100%; }

        .visual-block-wrapper img {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            pointer-events: none; /* Prevent native drag, let wrapper handle it */
        }

        .visual-block-wrapper:hover {
            border-color: rgba(0,0,0,0.1);
            background: rgba(0,0,0,0.02);
        }
        
        .visual-block-wrapper {
            display: block; 
            margin: 24px auto; 
            padding: 10px; 
            border: 1px solid transparent; 
            position: relative; /* For controls */
            border-radius: 8px;
            transition: var(--transition);
            cursor: pointer;
        }

        /* --- DARK MODE OVERRIDES (Softer) --- */
        body.dark-mode {
            /* Base Background: Dark Grey (Not Pitch Black) */
            --bg-app: #18181b; 
            background-image: none; /* Remove gradient for cleaner look */
            
            /* Glass: Slightly lighter gray with blur */
            --glass-bg: rgba(39, 39, 42, 0.8);
            --glass-border: rgba(255, 255, 255, 0.08);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
            
            --text: #e4e4e7; /* Off-white text */
        }

        /* Editor Paper: Distinct from background, but soft */
        body.dark-mode #editor {
            background: #27272a; 
            color: #e4e4e7;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        /* Text Colors */
        body.dark-mode #docTitle { color: #fff; }
        body.dark-mode #docTitle::placeholder { color: #52525b; }
        body.dark-mode #editor h1, 
        body.dark-mode #editor h2 { color: #fff; }
        body.dark-mode #editor h3 { color: #a1a1aa; }

        /* Toolbar & Menus */
        body.dark-mode .toolbar-container { background: #27272a; border-color: #3f3f46; }
        body.dark-mode .dropdown-content { background: #27272a; border: 1px solid #3f3f46; }
        body.dark-mode .dropdown-item { color: #d4d4d8; }
        body.dark-mode .dropdown-item:hover { background: var(--primary); color: white; }
        body.dark-mode .btn-text { color: #a1a1aa; }
        body.dark-mode .btn-text:hover { background: rgba(255,255,255,0.1); color: #fff; }

        /* Visual Blocks (Charts/Code) */
        body.dark-mode .visual-block-wrapper { background: #18181b; border-color: #3f3f46; }
        body.dark-mode details.markscheme { background: #18181b; border-color: #3f3f46; }
        body.dark-mode details.markscheme summary { background: #27272a; color: #e4e4e7; }
        body.dark-mode .code-block-wrapper pre { background: #121212; border: 1px solid #333; }
        body.dark-mode .block-container math-field { background: #d4d4d8; color: black; } /* Light math for contrast */
        
        /* Inputs in Builder Modals */
        body.dark-mode .builder-section, 
        body.dark-mode .builder-panel,
        body.dark-mode .modal { background: #27272a; color: #fff; border-color: #3f3f46; }
        body.dark-mode .builder-input,
        body.dark-mode .builder-select { background: #18181b; color: white; border-color: #3f3f46; }
        body.dark-mode .builder-header { color: #a1a1aa; }
        body.dark-mode .btn-icon { background: #3f3f46; color: white; }
        
        /* 1. Standard Math: Make text white/light gray */
        body.dark-mode math-field {
            color: #ececec; 
            background: rgba(255, 255, 255, 0.05); /* Slight bg for contrast */
            border-color: #555;
        }

        /* 2. Chem Math: Make text Light Green (instead of dark green) */
        body.dark-mode math-field.chem-field {
            color: #86efac !important; /* Light Pastel Green */
            background: rgba(52, 199, 89, 0.15);
        }

        /* 3. Blockquotes: Make text readable and bg subtle */
        body.dark-mode .quote-wrapper blockquote {
            background: rgba(255, 255, 255, 0.05);
            color: #d4d4d8;
            border-left-color: var(--primary);
        }

        /* 4. Ensure Inline Code is visible */
        body.dark-mode .inline-code {
            background: #333;
            color: #f9a8d4; /* Light Pink for contrast */
            border-color: #444;
        }


        /* --- Custom Toggle Switch --- */
        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            margin-left: auto; /* Push to right */
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; border-radius: 34px;
            transition: .4s;
        }
        .slider:before {
            position: absolute; content: "";
            height: 18px; width: 18px; left: 3px; bottom: 3px;
            background-color: white; border-radius: 50%;
            transition: .4s; box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(20px); }
        
        /* Dark mode adjustments for toggle */
        body.dark-mode .slider { background-color: #555; }
        
        /* --- Custom Dialog Modal (Alerts/Confirms) --- */
        #dialogModal .modal {
            max-width: 400px; text-align: center;
            padding: 25px; align-items: center;
        }
        .dialog-icon {
            font-size: 3rem; color: var(--primary);
            margin-bottom: 10px;
        }
        .dialog-icon.warning { color: var(--danger); }
        .dialog-msg { margin-bottom: 20px; color: #555; font-size: 0.95rem; }
        body.dark-mode .dialog-msg { color: #ccc; }

        /* Dark mode table fixes */
        body.dark-mode table { background: #27272a; color: #e4e4e7; }
        body.dark-mode th { background: #1f1f22; border-color: #3f3f46; }
        body.dark-mode td { border-color: #3f3f46; }

        

        table {
            width: 100%; border-collapse: collapse; background: white;
            border-radius: 8px; overflow: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        th, td { border: 1px solid #eee; padding: 10px; min-width: 50px; position: relative; }
        th { background-color: #f8f9fa; font-weight: 600; text-align: left; }

        /* --- UPDATED: Table Controls --- */
        .table-wrapper {
            position: relative; 
            margin: 25px 0 35px 0; 
            border-radius: 8px; 
            border: 1px solid transparent; 
            transition: var(--transition); 
            display: inline-block; 
            min-width: 50%;
        }
        .table-wrapper:hover { border-color: rgba(0,0,0,0.1); }

        /* Controls for Columns (Bottom) */
        .table-controls-x {
            position: absolute; 
            bottom: -32px; 
            height: 30px;
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 5px;
            opacity: 0; 
            pointer-events: none; 
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
        }

        /* Controls for Rows (Right) */
        .table-controls-y {
            position: absolute; 
            right: -32px; 
            width: 30px;
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            gap: 5px;
            opacity: 0; 
            pointer-events: none; 
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 100;
        }

        /* Show on hover OR when active */
        .table-wrapper:hover .table-controls-x, 
        .table-wrapper:hover .table-controls-y,
        .table-wrapper.active-focus .table-controls-x,
        .table-wrapper.active-focus .table-controls-y,
        .table-wrapper:hover .btn-block-delete {
            opacity: 1; pointer-events: auto;
        }

        /* Mini Buttons */
        .btn-mini-control {
            width: 24px; height: 24px; border-radius: 4px; 
            border: 1px solid #ddd; background: white; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 14px; color: #555; box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: 0.2s;
        }
        .btn-mini-control:hover { background: var(--primary); color: white; border-color: var(--primary); transform: scale(1.1); }
        .btn-mini-control.danger:hover { background: var(--danger); border-color: var(--danger); }
        body.dark-mode .btn-mini-control { background: #333; border-color: #444; color: #aaa; }

        /* --- NEW: Strikethrough & Links --- */
        s, strike, del { text-decoration: line-through; color: #888; }
        a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: 0.2s; cursor: pointer; }
        a:hover { border-bottom-color: var(--primary); opacity: 0.8; }

        /* --- FIX: Bullet Points --- */
        #editor ul { 
            list-style-type: disc; 
            padding-left: 40px; 
        }
        #editor ol { 
            list-style-type: decimal; 
            padding-left: 40px; 
        }

        /* --- NEW: Native-Feel Task Lists --- */
        /* We hide the default bullet and draw a box instead */
        ul.task-list {
            list-style-type: none !important; 
            padding-left: 40px; 
        }

        ul.task-list li {
            position: relative;
            margin-bottom: 4px;
        }

        /* The Checkbox (drawn via CSS) */
        ul.task-list li::before {
            content: '';
            position: absolute;
            left: -25px;
            top: 6px;
            width: 16px;
            height: 16px;
            border: 2px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: 0.2s;
        }

        /* Hover effect on the checkbox area */
        ul.task-list li:hover::before {
            border-color: var(--primary);
        }

        /* Checked State (Class added via JS) */
        ul.task-list li.checked::before {
            background: var(--primary);
            border-color: var(--primary);
            content: 'âœ”'; /* Simple checkmark */
            color: white;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
        }

        /* Strikethrough text when checked */
        ul.task-list li.checked {
            text-decoration: line-through;
            color: #aaa;
        }

        /* Dark Mode Adjustments */
        body.dark-mode ul.task-list li::before { background: #333; border-color: #555; }
        body.dark-mode ul.task-list li.checked::before { background: var(--primary); border-color: var(--primary); }


        /* The Drop Target Indicator (Blue Line) */
        #drop-indicator {
            position: absolute;
            height: 4px;
            background: var(--primary);
            border-radius: 2px;
            pointer-events: none;
            display: none;
            z-index: 9999;
            box-shadow: 0 0 10px var(--primary-glow);
            transition: top 0.1s;
        }

        /* The Drag Handle (:: marker) */
        .drag-handle {
            position: absolute;
            top: -5px; /* Sit slightly above the block */
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 15px;
            background: #e0e0e0;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: 0.2s;
            z-index: 100;
        }

        .drag-handle::after {
            content: '::::';
            font-size: 10px;
            font-weight: 900;
            color: #888;
            line-height: 0;
            letter-spacing: 1px;
        }

        .drag-handle:active { cursor: grabbing; background: var(--primary); }
        .drag-handle:active::after { color: white; }

        /* Show handle on hover */
        .visual-block-wrapper:hover .drag-handle,
        .code-block-wrapper:hover .drag-handle,
        .quote-wrapper:hover .drag-handle,
        .block-container:hover .drag-handle,
        .table-wrapper:hover .drag-handle,
        details.markscheme:hover .drag-handle {
            opacity: 1;
        }

        /* Make images draggable directly, but disable browser default ghost */
        #editor img {
            cursor: grab;
            -webkit-user-drag: none; /* Disable native browser drag */
        }
        #editor img:active { cursor: grabbing; }

        /* Add Draggable State Styling */
        .is-dragging {
            opacity: 0.4;
            filter: grayscale(1);
            /* CRITICAL: Allows mouse to interact with elements UNDER the dragged item */
            pointer-events: none !important; 
        }

        /* --- PROFESSIONAL PRINT STYLES --- */
        @media print {
            /* 1. Page Setup */
            @page {
                margin: 2cm;
                size: auto;
            }

            /* 2. Global Resets */
            body, body.dark-mode {
                background: white !important;
                color: black !important;
                padding: 0 !important;
                margin: 0 !important;
                overflow: visible !important;
                /* Use a crisp system font for print */
                font-family: 'Helvetica', 'Arial', sans-serif;
                font-size: 12pt !important;
                line-height: 1.5;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            /* 3. Hide UI Elements */
            .header-area, 
            .sticky-wrapper, 
            .modal-overlay, 
            .btn-block-delete, 
            .table-controls-x, 
            .table-controls-y,
            .drag-handle,
            .toggle-switch,
            #drop-indicator,
            ::-webkit-scrollbar {
                display: none !important;
            }

            /* 4. Editor Container Clean-up */
            #editor {
                margin: 0 !important;
                padding: 0 !important;
                box-shadow: none !important;
                border: none !important;
                width: 100% !important;
                max-width: 100% !important;
                min-height: auto !important;
                background: white !important;
                color: black !important;
                overflow: visible !important;
            }

            /* 5. Typography & Headers */
            #editor h1 { font-size: 24pt; margin-top: 0; border-bottom: 2px solid #000; padding-bottom: 5px; color: #000; }
            #editor h2 { font-size: 18pt; margin-top: 20px; color: #000; border-bottom: 1px solid #ccc; }
            #editor h3 { font-size: 14pt; margin-top: 15px; color: #333; }
            #editor p, #editor li { font-size: 12pt; color: #000; }

            /* 6. Links (Make them text-only, no blue) */
            a {
                text-decoration: underline;
                color: #000 !important;
                border: none;
            }
            /* Optional: Show URL after link? Uncomment if desired:
            a::after { content: " (" attr(href) ")"; font-size: 0.8em; color: #555; } */

            /* 7. Code Blocks (Ink Saver Mode) */
            /* Turn dark blocks into white blocks with borders */
            .code-block-wrapper pre {
                background: #fff !important;
                border: 1px solid #ccc;
                color: #000 !important;
                font-family: 'Courier New', monospace;
                font-size: 10pt;
                white-space: pre-wrap; /* Wrap text so it doesn't get cut off */
                box-shadow: none;
                padding: 10px;
            }
            .inline-code {
                background: #f0f0f0 !important;
                border: 1px solid #ddd;
                color: #000 !important;
            }

            /* 8. Math & Chemistry */
            math-field, 
            math-field.chem-field {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
                color: black !important;
                font-size: 12pt; /* Ensure math matches text size */
            }
            /* Remove the green tint from Chem fields to save color ink */
            math-field.chem-field {
                background-color: transparent !important;
            }

            /* 9. Visual Blocks (Charts, Images, Mermaid) */
            .visual-block-wrapper {
                border: none !important;
                background: transparent !important;
                margin: 20px 0;
                page-break-inside: avoid; /* Prevent cutting images in half */
                text-align: center;
            }
            
            /* Hide "Double click to edit" */
            .visual-block-wrapper::after { display: none !important; }

            img, canvas, svg {
                max-width: 100% !important;
                height: auto !important;
                display: block;
                margin: 0 auto;
                page-break-inside: avoid;
            }

            /* 10. Tables */
            table {
                width: 100% !important;
                border-collapse: collapse;
                border: 1px solid #000;
                page-break-inside: avoid;
            }
            th, td {
                border: 1px solid #000 !important; /* Crisp black borders */
                padding: 8px;
                color: #000;
            }
            th {
                background-color: #f0f0f0 !important; /* Light grey header */
                font-weight: bold;
            }

            /* 11. Markschemes (Force Open) */
            details.markscheme {
                border: 1px solid #ccc;
                background: none !important;
                page-break-inside: avoid;
                margin: 15px 0;
            }
            details.markscheme summary {
                background: #f9f9f9 !important;
                font-weight: bold;
                list-style: none; /* Hide arrow if desired */
            }
            /* Force markscheme content to be visible even if closed on screen */
            details.markscheme[open] .markscheme-content,
            details.markscheme:not([open]) .markscheme-content {
                display: block !important; 
            }

            /* 12. Blockquotes */
            .quote-wrapper blockquote {
                background: transparent !important;
                border-left: 4px solid #ccc !important;
                color: #444 !important;
                font-style: italic;
            }
            
            /* 13. Task Lists */
            ul.task-list li::before {
                border-color: #000 !important; /* Black checkboxes */
            }
            ul.task-list li.checked::before {
                background: #eee !important;
                color: #000 !important;
            }
        }

        .visual-block-wrapper.type-image::after {
            content: none !important;
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Sentinel for Sticky Observer -->
    <div id="scroll-sentinel" style="position: absolute; top: 120px; left: 0; width: 100%; height: 1px; pointer-events: none; opacity: 0;"></div>
    <!-- Header Area (Title) -->
    <div class="header-area">
        <input type="text" id="docTitle" placeholder="Untitled Document" spellcheck="false" autocomplete="off" oninput="syncTitle('main')">
    </div>

    <!-- Sticky Toolbar (New UI) -->
    <div class="sticky-wrapper" id="stickyWrapper">
        <div class="toolbar-container">
            
            <!-- Row 1: Mini Title + Formatting + Math -->
            <div class="toolbar-row">
                <!-- Editable Mini Title -->
                <div class="mini-title-wrapper">
                    <input type="text" id="miniTitleInput" placeholder="Untitled" oninput="syncTitle('mini')">
                </div>

                <!-- Styles Dropdown -->
                <div class="dropdown-wrapper" id="styleDropdown">
                    <button class="tool-btn btn-text" id="styleLabel">Normal</button>
                    <div class="dropdown-content">
                        <button class="dropdown-item" onclick="selectStyle('p', 'Normal')" style="font-size: 0.7rem; font-weight: 300;">Normal</button>
                        <button class="dropdown-item" onclick="selectStyle('h1', 'Heading 1')" style="font-size: 1.3rem; font-weight: 900;">Heading 1</button>
                        <button class="dropdown-item" onclick="selectStyle('h2', 'Heading 2')" style="font-size: 1.1rem; font-weight: 700;">Heading 2</button>
                        <button class="dropdown-item" onclick="selectStyle('h3', 'Heading 3')" style="font-size: 0.9rem; font-weight: 500;">Heading 3</button>
                        <button class="dropdown-item" onclick="selectStyle('h4', 'Heading 4')" style="font-size: 0.825rem; font-weight: 450;">Heading 4</button>
                        <button class="dropdown-item" onclick="selectStyle('h5', 'Heading 5')" style="font-size: 0.75rem; font-weight: 400;">Heading 5</button>
                    </div>
                </div>

                <div class="divider"></div>

                <!-- Formatting -->
                <button class="tool-btn" id="btnBold" onclick="toggleFormat('bold')" title="Bold"><i class="ph ph-text-b"></i></button>
                <button class="tool-btn" id="btnItalic" onclick="toggleFormat('italic')" title="Italic"><i class="ph ph-text-italic"></i></button>
                <button class="tool-btn" id="btnUnderline" onclick="toggleFormat('underline')" title="Underline"><i class="ph ph-text-underline"></i></button>
                <button class="tool-btn" id="btnStrike" onclick="toggleFormat('strikeThrough')" title="Strikethrough"><i class="ph ph-text-strikethrough"></i></button>

                <div class="divider"></div>

                <!-- Math & Chem -->
                <button class="tool-btn btn-math" onclick="insertMath('inline')" title="Inline Math"><i class="ph ph-sigma"></i></button>
                <button class="tool-btn btn-math" onclick="insertMath('block')" title="Block Math"><i class="ph ph-function" style="font-weight:bold;"></i></button>
                <button class="tool-btn btn-chem" onclick="insertChem('inline')" title="Inline Chem"><i class="ph ph-flask"></i></button>
                <button class="tool-btn btn-chem" onclick="insertChem('block')" title="Block Chem"><i class="ph ph-flask" style="font-weight:bold; border: 2px solid currentColor; border-radius: 4px; padding: 2px; font-size: 0.7rem;"></i></button>

                <!-- Link -->
                <button class="tool-btn" onclick="openLinkModal()" title="Insert Link"><i class="ph ph-link"></i></button>
            </div>

            <!-- Row 2: Menus & Actions -->
            <div class="toolbar-row secondary">
                
                <!-- File Menu -->
                <div class="dropdown-wrapper">
                    <button class="tool-btn btn-text">File</button>
                    <div class="dropdown-content">
                        <button class="dropdown-item" onclick="createNewDoc(true)"><i class="ph ph-file-plus"></i> New File</button>
                        <button class="dropdown-item" onclick="openFileManager()"><i class="ph ph-folder-open"></i> View Files</button>
                        <button class="dropdown-item" onclick="saveToLocal(true)"><i class="ph ph-floppy-disk"></i> Save Now</button>
                        <button class="dropdown-item" onclick="saveAsFile()"><i class="ph ph-download-simple"></i> Save As...</button>                                                

                        <div style="height:1px; background:#eee; margin:4px 0;"></div>
                        <button class="dropdown-item" onclick="downloadMarkdown()"><i class="ph ph-export"></i> Export .md</button>
                        <label class="dropdown-item" style="cursor:pointer">
                            <i class="ph ph-upload-simple"></i> Import .md
                            <input type="file" id="mdUploadInput" accept=".md" style="display:none" onchange="importMarkdown(this)">
                        </label>
                    </div>
                </div>

                <!-- Insert Menu -->
                <div class="dropdown-wrapper">
                    <button class="tool-btn btn-text">Insert</button>
                    <div class="dropdown-content">
                        <button class="dropdown-item" onclick="insertList('ul')"><i class="ph ph-list-bullets"></i> Bullet List</button>
                        <button class="dropdown-item" onclick="insertList('ol')"><i class="ph ph-list-numbers"></i> Numbered List</button>
                        <button class="dropdown-item" onclick="insertTaskList()"><i class="ph ph-check-square"></i> Task List</button>
                        <div style="height:1px; background:#eee; margin:4px 0;"></div>
                        <button class="dropdown-item" onclick="insertQuote()"><i class="ph ph-quotes"></i> Blockquote</button>
                        <button class="dropdown-item" onclick="insertCodeBlock()"><i class="ph ph-code-block"></i> Code Block</button>
                        <button class="dropdown-item" onclick="insertInlineCode()"><i class="ph ph-code"></i> Inline Code</button>
                        <div style="height:1px; background:#eee; margin:4px 0;"></div>
                        <button class="dropdown-item" onclick="openImageModal()"><i class="ph ph-image"></i> Image</button>
                        <button class="dropdown-item" onclick="openFlowchartModal()"><i class="ph ph-tree-structure"></i> Flowchart</button>
                        <button class="dropdown-item" onclick="openChartJsModal()"><i class="ph ph-chart-bar"></i> Chart</button>
                        <button class="dropdown-item" onclick="openDesmosModal()"><i class="ph ph-calculator"></i> Calculator</button>
                        <button class="dropdown-item" onclick="insertMarkscheme()"><i class="ph ph-list-checks"></i> Markscheme</button>
                        <button class="dropdown-item" onclick="insertTable()"><i class="ph ph-table"></i> Table</button>
                        
                    </div>
                </div>

                <div class="dropdown-wrapper">
                    <button class="tool-btn btn-text">Config</button>
                    <div class="dropdown-content">
                        <div class="dropdown-item" style="cursor:default; justify-content: space-between;" onclick="toggleDarkModeWrapper(event)">
                            <span><i class="ph ph-moon" style="display: inline-flex; align-items:center"></i> Dark</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="darkModeToggle">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <button class="dropdown-item" onclick="openHelp()"><i class="ph ph-question"></i> Help</button>
                    </div>
                </div>

                <div class="divider"></div>

                <!-- Utilities -->
                <button class="tool-btn" onclick="document.execCommand('undo')" title="Undo" style="width:32px; height:32px; font-size:1.1rem"><i class="ph ph-arrow-u-up-left"></i></button>
                <button class="tool-btn" onclick="document.execCommand('redo')" title="Redo" style="width:32px; height:32px; font-size:1.1rem"><i class="ph ph-arrow-u-up-right"></i></button>
                <div class="divider"></div>
                <button class="tool-btn" onclick="window.print()" title="Print" style="width:32px; height:32px; font-size:1.1rem"><i class="ph ph-printer"></i></button>

            </div>
        </div>
    </div>

    <!-- The Paper -->
    <div id="editor" contenteditable="true" spellcheck="false" oninput="saveToLocal()">
        <h1>Markdown Editor</h1>
        <p>Start typing here...</p>
    </div>

    <!-- NEW: Drop Indicator Line -->
    <div id="drop-indicator"></div>

    <!-- Hidden Temp Calculator for Screenshot Generation -->
    <div id="tempCalculator"></div>

    <!-- File Manager Modal -->
    <div id="fileModal" class="modal-overlay">
        <div class="modal">
            <h3>Saved Files</h3>
            <div id="fileList"></div>
            
            <div style="display: flex; justify-content: flex-end; gap: 10px; width: 100%; margin-top: 10px;">
                <!-- CLEAR ALL BUTTON (Far Left) -->
                <button class="btn-glass" style="background: var(--danger); color: white; margin-right: auto;" onclick="clearAllStorage()">
                    <i class="ph ph-trash"></i> Clear All
                </button>

                <button class="btn-glass" onclick="createNewDoc()"><i class="ph ph-plus"></i> New File</button>
                <button class="btn-glass btn-glass-cancel" onclick="document.getElementById('fileModal').classList.remove('active')">Close</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal" style="width: 600px; max-height: 80vh; overflow-y: auto;">
            <h3>Editor Help</h3>
            <div id="helpContent" style="line-height: 1.6; color: #444; font-size: 0.95rem;">
                <!-- Content injected via JS -->
            </div>
            <button class="btn-glass btn-glass-cancel" onclick="document.getElementById('helpModal').classList.remove('active')" style="align-self: flex-end; margin-top:20px;">Close</button>
        </div>
    </div>

    <!-- SINGLE UNIVERSAL BUILDER MODAL -->
    <div id="builderModal" class="modal-overlay">
        <div class="modal large-modal" id="builderModalContent">
            <!-- Dynamic Content Here -->
        </div>
    </div>

    <!-- Custom Dialog Modal -->
    <div id="dialogModal" class="modal-overlay" style="z-index: 6000;">
        <div class="modal">
            <div id="dialogIcon" class="dialog-icon"><i class="ph ph-info"></i></div>
            <h3 id="dialogTitle">Alert</h3>
            <p id="dialogMsg" class="dialog-msg">Message goes here...</p>
            <div class="modal-actions" style="width: 100%; justify-content: center; gap: 15px;">
                <button id="dialogBtnCancel" class="btn-glass btn-glass-cancel" onclick="closeDialog(false)">Cancel</button>
                <button id="dialogBtnConfirm" class="btn-glass btn-glass-insert active" onclick="closeDialog(true)">OK</button>
            </div>
        </div>
    </div>

    <script>
        console.log(`       
                ============================================================
                âš ï¸ DESMOS API DISCLAIMER â€“ REQUIRED NOTICE âš ï¸
                ============================================================

                This project references or utilizes elements of the Desmos Graphing Calculator
                or its API. Please be aware of the following critical usage restrictions:

                1. Desmos does NOT offer public or open access to their API.
                Any integration beyond their public graphing calculator embed
                must be explicitly approved through Desmosâ€™s official Partnership Program.

                2. API keys and advanced features (e.g., programmatic graph creation,
                data syncing, deep integrations) require PRIOR authorization.

                3. Unauthorized use of the Desmos APIâ€”including accessing endpoints
                without permission, reverse engineering, scraping, or automated accessâ€”
                is strictly forbidden and may violate Desmosâ€™s Terms of Service.

                4. If you wish to use the Desmos API legally and safely, you MUST:
                - Apply at https://www.desmos.com/partners
                - Receive approval and credentials from Desmos, Inc.
                - Follow all relevant documentation and branding guidelines

                5. This project is NOT affiliated with or endorsed by Desmos, Inc.
                All trademarks and services belong to their respective owners.

                Failure to comply with these terms can result in:
                - API access revocation
                - Legal action
                - Application malfunction or incompatibility
                - User data loss or privacy violations

                ðŸ”— Official API access: https://www.desmos.com/partners
                ðŸ”— Terms of Service: https://www.desmos.com/terms
                ðŸ”— Privacy Policy: https://www.desmos.com/privacy

                DO NOT use the Desmos API in production or distributed applications
                without explicit permission from Desmos.

                ============================================================


        `);
        // --- 0. Tooltip Logic & Init ---
        function initTooltips() {
            document.querySelectorAll('[title]').forEach(el => {
                if (el.tagName !== 'IFRAME' && el.tagName !== 'STYLE' && el.tagName !== 'SCRIPT') {
                    const text = el.getAttribute('title');
                    el.setAttribute('data-tooltip', text);
                    el.removeAttribute('title');
                }
            });
        }

        // --- 1. Constants & Init ---
        mermaid.initialize({ startOnLoad: false, theme: 'neutral', flowchart: { htmlLabels: true, curve: 'basis' } });

        const CHEM_LAYOUT = {
            label: "Chem", tooltip: "Chemistry",
            rows: [[{ label: "1", key: "1" }, { label: "2", key: "2" }, { label: "3", key: "3" }, { label: "4", key: "4" }, { label: "5", key: "5" }, { label: "+", key: "+" }, { label: "âˆ’", key: "-" }, { label: "=", key: "=" }, { label: "âŸ¶", latex: "\\longrightarrow" }, { label: "â‡Œ", latex: "\\rightleftharpoons" }], [{ label: "6", key: "6" }, { label: "7", key: "7" }, { label: "8", key: "8" }, { label: "9", key: "9" }, { label: "0", key: "0" }, { label: "(", key: "(" }, { label: ")", key: ")" }, { label: "<span>â—»</span><sup><span>â—»</span></sup>", latex: "^{#?}" }, { label: "<span>â—»</span><sub><span>â—»</span></sub>", latex: "_{#?}" }, { label: "Sup/Sub", latex: "_{#?}^{#?}" }], [{ label: "eâ»", latex: "e^-" }, { label: "Hâº", latex: "H^+" }, { label: "Î”", latex: "\\Delta" }, { label: "mol", latex: "\\text{mol}" }, { label: "(s)", latex: "_{(s)}" }, { label: "(l)", latex: "_{(l)}" }, { label: "(g)", latex: "_{(g)}" }, { label: "(aq)", latex: "_{(aq)}" }, { class: "action", label: "âŒ«", command: ["performWithFeedback", "deleteBackward"] }, { class: "action warning", label: "ðŸ—‘", command: "deleteAll" }]]
        };

        const editor = document.getElementById('editor');
        const imgModal = document.getElementById('imgModal');
        const imgUrlInput = document.getElementById('imgUrlInput');
        const imgFileInput = document.getElementById('imgFileInput');
        const btnInsertImg = document.getElementById('btnInsertImg');
        const docTitle = document.getElementById('docTitle');
        const builderModal = document.getElementById('builderModal');
        const builderModalContent = document.getElementById('builderModalContent');
        
        let savedRange = null;

        // --- 2. Title Sync & Local Storage ---
        let currentDocId = localStorage.getItem('current_id') || 'doc_' + Date.now();

        window.addEventListener('DOMContentLoaded', () => {
            initTooltips();
            loadCurrentDoc();

            if (localStorage.getItem('dark_mode') === 'true') {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeToggle').checked = true;
            }
            document.addEventListener('selectionchange', handleTableFocusChange); 
            document.getElementById('editor').addEventListener('keyup', checkFormatState);
            // --- FIX: ROBUST AUTO-SAVE (MutationObserver) ---
            // This watches for ANY change in the editor (typing, math, checkboxes, dragging)
            const observerConfig = { 
                childList: true,  // Watch for added/removed lines/blocks
                subtree: true,    // Watch everything deep inside
                characterData: true, // Watch text changes
                attributes: true, // Watch for class changes (like checkboxes)
                attributeFilter: ['class', 'value', 'checked'] // Optimization
            };

            const autoSaveObserver = new MutationObserver((mutations) => {
                // Trigger the DEBOUNCED save (waits 1s)
                saveToLocal(false);
            });

            // Start observing the editor
            autoSaveObserver.observe(document.getElementById('editor'), observerConfig);

            // --- FIX: MathLive Specific Listener ---
            // MathLive fields fire 'input' events that might escape the observer
            document.getElementById('editor').addEventListener('input', (e) => {
                // If it's a math-field, force a save trigger
                if (e.target.tagName.toLowerCase() === 'math-field') {
                    saveToLocal(false);
                }
            });

            editor.addEventListener('click', (e) => {
                if (e.target === editor) {
                    // Only if clicking below the last element
                    const lastChild = editor.lastElementChild;
                    if (lastChild) {
                        const rect = lastChild.getBoundingClientRect();
                        if (e.clientY > rect.bottom) {
                            const range = document.createRange();
                            range.selectNodeContents(editor);
                            range.collapse(false); // Move to end
                            const sel = window.getSelection();
                            sel.removeAllRanges();
                            sel.addRange(range);
                        }
                    }
                }
            });

            
            // --- FIX: Robust Sticky Observer (Sentinel Method) ---
            const observer = new IntersectionObserver((entries) => {
                const wrapper = document.getElementById('stickyWrapper');
                const miniInput = document.getElementById('miniTitleInput');
                
                // If the sentinel (top pixel) is NOT intersecting, we have scrolled down
                const isScrolledDown = !entries[0].isIntersecting;

                if (isScrolledDown) {
                    wrapper.classList.add('is-stuck');
                    miniInput.value = document.getElementById('docTitle').value || "Untitled Document";
                } else {
                    wrapper.classList.remove('is-stuck');
                }
            }, { threshold: 0 }); // REMOVED rootMargin to fix the "always stuck" bug
            
            // Ensure the sentinel exists before observing
            const sentinel = document.getElementById('scroll-sentinel');
            if (sentinel) observer.observe(sentinel);

            if (typeof MathfieldElement !== 'undefined') {
                // Only define this if the 'commands' property is exposed (Older versions)
                // Newer versions handle this differently, so we skip to avoid the crash.
                if (MathfieldElement.commands) {
                    MathfieldElement.commands.deleteEquation = (mf) => {
                        const parent = mf.parentElement;
                        if (parent) { 
                            setTimeout(() => { 
                                if(parent.classList.contains('math-wrapper')) parent.remove(); 
                                else if(parent.classList.contains('block-container')) parent.remove(); 
                                else mf.remove(); 
                                editor.focus(); 
                            }, 10); 
                        } 
                        return true;
                    };
                }
            }
            const allDocs = JSON.parse(localStorage.getItem('docs') || '{}');
            if (!allDocs[currentDocId]) {
                // If it doesn't exist, we are in "New Session" mode.
                // We set up the UI but we DO NOT call saveToLocal().
                document.getElementById('docTitle').value = "";
                editor.innerHTML = "<h1>Markdown Editor</h1><p>Start typing here...</p>";
            } else {
                loadCurrentDoc();
            }
            
        }); 

        // Global Delete Handler
        editor.addEventListener('click', (e) => {
            const btn = e.target.closest('.btn-block-delete');
            if (btn) {
                e.preventDefault();
                e.stopPropagation();
                const wrapper = btn.parentElement;
                if (wrapper) {
                    wrapper.remove();
                    saveToLocal();
                }
            }
        });

        function syncTitle(source) {
            const main = document.getElementById('docTitle');
            const mini = document.getElementById('miniTitleInput');
            if(source === 'main') mini.value = main.value;
            else main.value = mini.value;
            saveToLocal();
        }

        // --- 1. Debounce Helper (Prevents lag while typing) ---
        function debounce(func, wait) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        }

        // --- 2. The Actual Save Execution ---
        function performSave() {
            // Critical: Update MathLive fields so their content is saved in the HTML
            editor.querySelectorAll('math-field').forEach(mf => {
                mf.setAttribute('value', mf.value);
            });

            const title = document.getElementById('docTitle').value || "Untitled Document";
            const content = editor.innerHTML;
            
            const meta = {
                id: currentDocId,
                title: title,
                content: content,
                date: new Date().toLocaleString(),
                size: (content.length / 1024).toFixed(2) + ' KB'
            };
            
            let allDocs = JSON.parse(localStorage.getItem('docs') || '{}');
            allDocs[currentDocId] = meta;
            localStorage.setItem('docs', JSON.stringify(allDocs));
            localStorage.setItem('current_id', currentDocId);
            
        }

        // --- 3. The Debounced Trigger (Waits 1 second) ---
        const triggerAutoSave = debounce(performSave, 1000);

        // --- 4. Main Function (Call this on input) ---
        function saveToLocal(force = false) {
            if (force) {
                performSave(); // Save Immediately
            } else {
                triggerAutoSave(); // Wait for user to stop typing
            }
        }

        function loadCurrentDoc() {
            const allDocs = JSON.parse(localStorage.getItem('docs') || '{}');
            const meta = allDocs[currentDocId];
            if (meta) {
                document.getElementById('docTitle').value = meta.title;
                document.getElementById('miniTitleInput').value = meta.title;
                
                editor.innerHTML = meta.content; // DOM is created here
                
                // Re-attach all listeners immediately
                setTimeout(() => {
                    hydrateDOM(); 
                }, 50);
            }
        }

        // --- 3. File Manager Logic ---
        function openFileManager() {
            const allDocs = JSON.parse(localStorage.getItem('docs') || '{}');
            const list = document.getElementById('fileList');
            list.innerHTML = '';
            
            if(Object.keys(allDocs).length === 0) {
                list.innerHTML = '<p style="text-align:center; color:#888;">No saved files found.</p>';
            } else {
                Object.values(allDocs).sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(doc => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    item.innerHTML = `
                        <div class="file-info">
                            <span class="file-name">${doc.title}</span>
                            <span class="file-meta">${doc.date} â€¢ ${doc.size}</span>
                        </div>
                        <div class="file-actions">
                            <button class="btn-glass" onclick="loadDoc('${doc.id}')">Open</button>
                            <button class="btn-glass btn-glass-cancel" onclick="deleteDoc('${doc.id}')"><i class="ph ph-trash"></i></button>
                        </div>
                    `;
                    list.appendChild(item);
                });
            }
            document.getElementById('fileModal').classList.add('active');
            toggleScrollLock(true); // LOCK
        }

        function loadDoc(id) { currentDocId = id; localStorage.setItem('current_id', id); loadCurrentDoc(); document.getElementById('fileModal').classList.remove('active'); }
        
        // --- Keyboard Logic ---
        window.addEventListener('DOMContentLoaded', () => {
            if (typeof MathfieldElement !== 'undefined') {
                MathfieldElement.commands.deleteEquation = (mf) => {
                    const parent = mf.parentElement;
                    if (parent) { setTimeout(() => { if(parent.classList.contains('math-wrapper')) parent.remove(); else if(parent.classList.contains('block-container')) parent.remove(); else mf.remove(); editor.focus(); }, 10); } return true;
                };
            }
        });
        document.addEventListener('focusin', (e) => { if (e.target.tagName && e.target.tagName.toLowerCase() === 'math-field') { updateKeyboardLayout(e.target); if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.show(); } });
        document.addEventListener('focusout', (e) => { if (e.target.tagName && e.target.tagName.toLowerCase() === 'math-field') { setTimeout(() => { if (!document.activeElement || document.activeElement.tagName.toLowerCase() !== 'math-field') { if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.hide(); } }, 50); } });
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') { 
                if (window.mathVirtualKeyboard) window.mathVirtualKeyboard.hide(); 
                closeImageModal(); 
                closeBuilderModal(); 
                document.getElementById('fileModal').classList.remove('active');
                document.activeElement.blur(); 
            }
        });
        function updateKeyboardLayout(target) { if (!window.mathVirtualKeyboard) return; if (target.classList.contains('chem-field')) window.mathVirtualKeyboard.layouts = [CHEM_LAYOUT]; else window.mathVirtualKeyboard.layouts = "default"; }

        // --- Editor Helpers ---
        function selectStyle(tag, label) { document.execCommand('formatBlock', false, tag); document.getElementById('styleLabel').innerText = label; editor.focus(); }
        function toggleFormat(cmd) { document.execCommand(cmd, false, null); editor.focus(); checkFormatState(); }
        function checkFormatState() {
            // 1. Toggle Button Highlights (Keep existing logic)
            document.getElementById('btnBold').classList.toggle('active-state', document.queryCommandState('bold'));
            document.getElementById('btnItalic').classList.toggle('active-state', document.queryCommandState('italic'));
            document.getElementById('btnUnderline').classList.toggle('active-state', document.queryCommandState('underline'));
            document.getElementById('btnStrike').classList.toggle('active-state', document.queryCommandState('strikeThrough'));
            
            // 2. Determine Block Type (Fixing the "Stuck Label" bug)
            const selection = window.getSelection();
            let labelFound = "Normal"; // Default fallback if nothing is found

            if (selection.rangeCount > 0) {
                let node = selection.anchorNode;
                
                // Climb up the DOM tree from the cursor
                while (node && node !== editor) {
                    if (node.nodeType === 1) { // If it's an Element (not text)
                        const tag = node.tagName.toUpperCase();
                        const labelMap = { 
                            'P': 'Normal', 
                            'H1': 'Heading 1', 
                            'H2': 'Heading 2', 
                            'H3': 'Heading 3', 
                            'H4': 'Heading 4', 
                            'H5': 'Heading 5',
                            // Optional: Add these for better UX
                            'BLOCKQUOTE': 'Quote',
                            'PRE': 'Code',
                            'LI': 'List'
                        };
                        
                        if (labelMap[tag]) { 
                            labelFound = labelMap[tag]; 
                            break; // Stop looking once we find the closest match
                        }
                    }
                    node = node.parentNode;
                }
            }
            
            // 3. Apply the label (Always update, even if we fell back to "Normal")
            document.getElementById('styleLabel').innerText = labelFound;
        }
        document.addEventListener('selectionchange', () => { if (document.activeElement === editor || editor.contains(document.activeElement)) checkFormatState(); });
        document.execCommand('defaultParagraphSeparator', false, 'p');

        // --- Formatting Functions ---
        function insertList(type) {
            if(type === 'ul') document.execCommand('insertUnorderedList', false, null);
            if(type === 'ol') document.execCommand('insertOrderedList', false, null);
            editor.focus();
        }

        function insertQuote() {
            const wrapper = document.createElement('div'); wrapper.className = "quote-wrapper"; wrapper.contentEditable = "false";
            const bq = document.createElement('blockquote'); bq.contentEditable = "true"; bq.innerText = "Quote text...";
            wrapper.appendChild(bq); attachBlockControls(wrapper); insertNodeAtCursor(wrapper); wrapperAfter(wrapper); setTimeout(() => { bq.focus(); }, 10);
        }

        function insertCodeBlock() {
            const wrapper = document.createElement('div'); wrapper.className = "code-block-wrapper"; wrapper.contentEditable = "false";
            const pre = document.createElement('pre'); pre.contentEditable = "true"; pre.innerText = "Code...";
            wrapper.appendChild(pre); attachBlockControls(wrapper); insertNodeAtCursor(wrapper); wrapperAfter(wrapper); setTimeout(() => { pre.focus(); }, 10);
        }

        function insertInlineCode() {
            const wrapper = document.createElement('span'); wrapper.className = 'code-wrapper'; wrapper.contentEditable = "false";
            const code = document.createElement('span'); code.className = 'inline-code'; code.contentEditable = "true"; code.innerText = "code";
            wrapper.appendChild(code);
            const z1 = document.createTextNode('\u200B'); const z2 = document.createTextNode('\u200B');
            insertNodeAtCursor(z2); insertNodeAtCursor(wrapper); insertNodeAtCursor(z1);
            setTimeout(() => { const range = document.createRange(); range.selectNodeContents(code); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }, 10);
        }

        function createField(type) {
            const mf = new MathfieldElement(); mf.mathVirtualKeyboardPolicy = "manual"; 
            mf.addEventListener('focus-out', (ev) => { if (ev.detail.direction === 'forward') { const w = mf.parentElement; if (w && w.classList.contains('math-wrapper') && w.nextSibling) { const r = document.createRange(); r.setStart(w.nextSibling, 0); r.collapse(true); const s = window.getSelection(); s.removeAllRanges(); s.addRange(r); } } });
            if (type === 'chem') { mf.classList.add('chem-field'); mf.setAttribute('letter-shape-style', 'upright'); } else { mf.classList.add('math-field'); } return mf;
        }

        function insertMath(mode) { insertField('math', mode); }
        function insertChem(mode) { insertField('chem', mode); }
        function insertField(type, mode) {
            const mf = createField(type); mf.value = type === 'chem' ? "" : "x";
            if (mode === 'inline') {
                const wrapper = document.createElement('span'); wrapper.className = 'math-wrapper'; wrapper.contentEditable = "false"; wrapper.appendChild(mf);
                const z1 = document.createTextNode('\u200B'); const z2 = document.createTextNode('\u200B');
                insertNodeAtCursor(z2); insertNodeAtCursor(wrapper); insertNodeAtCursor(z1);
                setTimeout(() => mf.focus(), 50);
            } else {
                const container = document.createElement('div'); container.className = 'block-container'; container.contentEditable = "false"; container.appendChild(mf);
                attachBlockControls(container); 
                insertNodeAtCursor(container); const p = document.createElement('p'); p.innerHTML = "<br>"; container.after(p); setTimeout(() => mf.focus(), 50);
            }
        }
        function saveSelection() { const s = window.getSelection(); if (s.getRangeAt && s.rangeCount) savedRange = (editor.contains(s.anchorNode)) ? s.getRangeAt(0) : null; }
        function restoreSelection() { if (savedRange) { const s = window.getSelection(); s.removeAllRanges(); s.addRange(savedRange); } else editor.focus(); }
        function insertNodeAtCursor(node) { const s = window.getSelection(); if (!s.rangeCount) return; const r = s.getRangeAt(0); r.deleteContents(); r.insertNode(node); r.setStartAfter(node); r.setEndAfter(node); s.removeAllRanges(); s.addRange(r); }
        
        // --- BLOCK CONTROLS (Delete & Drag) ---
        function attachBlockControls(wrapper) {
            // 1. Delete Button
            if (!wrapper.querySelector('.btn-block-delete')) {
                const btn = document.createElement('div');
                btn.className = 'btn-block-delete';
                btn.innerHTML = '<i class="ph ph-trash"></i>';
                btn.contentEditable = "false";
                wrapper.appendChild(btn);
            }

            // 2. Drag Handle
            if (!wrapper.querySelector('.drag-handle')) {
                const handle = document.createElement('div');
                handle.className = 'drag-handle';
                handle.draggable = true; // The handle triggers the drag
                handle.contentEditable = "false";
                wrapper.appendChild(handle);
                
                // Attach Drag Events to the wrapper via the handle
                // Note: We attach dragstart to the handle, but move the wrapper
                handle.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    handleDragStart(e, wrapper);
                });
            }
        }

        // Call this helper for Images (which don't have wrappers/handles)
        function makeDraggable(element) {
            element.draggable = true;
            element.addEventListener('dragstart', (e) => handleDragStart(e, element));
        }

        // --- DRAG AND DROP ENGINE (IMPROVED) ---
        let draggedItem = null;
        const dropIndicator = document.getElementById('drop-indicator');

        // 1. Drag Start
        function handleDragStart(e, item) {
            if (item) {
                // We are dragging a block (Image/Graph/Table)
                draggedItem = item;
                e.dataTransfer.effectAllowed = 'move';
                // Put the HTML of the block into the dataTransfer
                e.dataTransfer.setData('text/html', item.outerHTML);
                requestAnimationFrame(() => item.classList.add('is-dragging'));
            } else {
                // We are dragging a text selection
                setClipboardData(e, true); 
            }
        }
        editor.addEventListener('dragstart', (e) => {
            // If target is NOT a draggable element/handle we set up, it's text
            if (!e.target.classList.contains('drag-handle') && 
                !e.target.classList.contains('visual-block-wrapper') &&
                e.target.tagName !== 'IMG') {
                
                handleDragStart(e, null); // Pass null to indicate text selection
            }
        });

        // 2. Drag Over
        let isDragOverThrottled = false;

        editor.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!draggedItem) return;

            // THROTTLE: Only run calculation if not currently waiting for a frame
            if (isDragOverThrottled) return;
            isDragOverThrottled = true;

            requestAnimationFrame(() => {
                const result = getDropLocation(editor, e.clientX, e.clientY);
                
                if (result.element) {
                    const rect = result.element.getBoundingClientRect();
                    dropIndicator.style.left = `${rect.left}px`;
                    dropIndicator.style.width = `${rect.width}px`;
                    dropIndicator.style.display = 'block';

                    if (result.position === 'before') {
                        dropIndicator.style.top = `${rect.top + window.scrollY - 4}px`;
                    } else {
                        dropIndicator.style.top = `${rect.bottom + window.scrollY + 4}px`;
                    }
                } else {
                    dropIndicator.style.display = 'none';
                }
                
                isDragOverThrottled = false; // Reset flag
            });
        });

        // 3. Drop
        editor.addEventListener('drop', (e) => {
            e.preventDefault();
            dropIndicator.style.display = 'none';

            // CASE A: Moving a Block (Existing Logic)
            if (draggedItem) {
                const result = getDropLocation(editor, e.clientX, e.clientY);
                if (result.element) {
                    if (result.position === 'before') editor.insertBefore(draggedItem, result.element);
                    else {
                        if (result.element.nextSibling) editor.insertBefore(draggedItem, result.element.nextSibling);
                        else editor.appendChild(draggedItem);
                    }
                } else {
                    editor.appendChild(draggedItem);
                }
                draggedItem.classList.remove('is-dragging');
                draggedItem = null;
                saveToLocal();
                return;
            }

            // CASE B: Dropping Text/HTML (New Logic)
            const html = e.dataTransfer.getData('text/html');
            if (html) {
                // 1. Prepare Insertion
                const isInternal = html.includes('<meta name="md-edit-source" content="internal">');
                
                // 2. Sanitize/Process (Reuse Paste Logic)
                // Note: DragDrop is usually like Ctrl+V (keep format), not Shift+V
                const cleanHTML = processPaste(html, isInternal, false); 

                // 3. Move Cursor to Drop Location (Crucial for insertHTML)
                // Browsers handle this differently for Drop, we need to manually set caret
                let range;
                if (document.caretRangeFromPoint) {
                    range = document.caretRangeFromPoint(e.clientX, e.clientY);
                } else if (e.rangeParent) {
                    range = document.createRange();
                    range.setStart(e.rangeParent, e.rangeOffset);
                }

                if (range) {
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }

                // 4. Insert
                document.execCommand('insertHTML', false, cleanHTML);

                // 5. Handle "Cut/Move" behavior for Internal Drags
                if (isInternal && internalDragRange) {
                    try {
                        // Delete the original text (The "Move" effect)
                        internalDragRange.deleteContents(); 
                    } catch(err) {
                        console.log("Could not delete original range (might have been overwritten)");
                    }
                    internalDragRange = null;
                }

                saveToLocal();
            }
        });

        editor.addEventListener('dragend', () => {
            if (draggedItem) draggedItem.classList.remove('is-dragging');
            dropIndicator.style.display = 'none';
            draggedItem = null;
        });

        // 4. Helper: Intelligent Drop Location Finder
        function getDropLocation(container, x, y) {
            // Strategy 1: Check exactly what element is under the mouse
            let target = document.elementFromPoint(x, y);
            
            // Climb up until we find a direct child of the editor
            // (e.g., if hovering <b> inside <p>, we want the <p>)
            while (target && target.parentElement !== container && target !== container) {
                target = target.parentElement;
            }

            // If we found a valid direct child that isn't the dragged item
            if (target && target.parentElement === container && target !== draggedItem && target.id !== 'drop-indicator') {
                const box = target.getBoundingClientRect();
                const offset = y - (box.top + box.height / 2);
                return {
                    element: target,
                    position: offset < 0 ? 'before' : 'after'
                };
            }

            // Strategy 2: Fallback (e.g., hovering in margins/gap)
            // Find closest element by pure math
            const elements = [...container.children].filter(child => 
                child !== draggedItem && 
                child.id !== 'drop-indicator' &&
                child.tagName !== 'STYLE' &&
                child.tagName !== 'SCRIPT' &&
                child.style.display !== 'none'
            );

            return elements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - (box.top + box.height / 2);
                
                if (Math.abs(offset) < Math.abs(closest.offset)) {
                    return { offset: offset, element: child, position: offset < 0 ? 'before' : 'after' };
                } else {
                    return closest;
                }
            }, { offset: Number.POSITIVE_INFINITY, element: null, position: 'end' });
        }

        // --- MODAL & BUILDER STATE ---
        function closeBuilderModal() {
            builderModal.classList.remove('active');
            setTimeout(() => { builderModalContent.innerHTML = ''; }, 300);
            editingChartElement = null; editingCjsElement = null; editingDesmosElement = null;
            if(cjsInstance) { cjsInstance.destroy(); cjsInstance = null; }
            if(calculator) { calculator.destroy(); calculator = null; }
        }

        // --- MERMAID FLOWCHART ---
        let chartNodes = [], chartEdges = [], editingChartElement = null;

        function openFlowchartModal(data = null) {
            saveSelection();
            builderModalContent.innerHTML = `
                <div class="builder-layout">
                    <div class="builder-panel">
                        <h3>Flowchart</h3>
                        <p style="font-size:0.8rem; color:#666; margin-top:-10px;">Define nodes and link them.</p>
                        <div class="builder-section">
                            <div class="builder-header">Nodes</div>
                            <div id="nodesList"></div>
                            <button class="btn-add-item" onclick="addChartNode()"><i class="ph ph-plus"></i> Add Node</button>
                        </div>
                        <div class="builder-section">
                            <div class="builder-header">Connections</div>
                            <div id="connectionsList"></div>
                            <button class="btn-add-item" onclick="addChartConnection()"><i class="ph ph-plus"></i> Add Connection</button>
                        </div>
                        <div style="flex:1"></div>
                        <button class="btn-glass btn-glass-cancel" onclick="closeBuilderModal()">Cancel</button>
                    </div>
                    <div class="preview-panel">
                        <div id="chartPreview"></div>
                        <div class="chart-actions">
                            <button class="btn-glass btn-glass-insert active" onclick="confirmInsertChart()">Insert Diagram</button>
                        </div>
                    </div>
                </div>
            `;
            builderModal.classList.add('active');
            if (data) { chartNodes = data.nodes; chartEdges = data.edges; } 
            else { chartNodes = [{id:'A',text:'Start',shape:'rect'},{id:'B',text:'End',shape:'rect'}]; chartEdges = [{from:'A',to:'B',text:''}]; }
            renderBuilderUI(); updateChartPreview();
        }

        function renderBuilderUI() {
            const nList = document.getElementById('nodesList'), eList = document.getElementById('connectionsList'); 
            if(!nList) return;
            nList.innerHTML = ''; eList.innerHTML = '';
            chartNodes.forEach((n, i) => {
                nList.innerHTML += `<div class="builder-row"><select class="builder-select" style="max-width:80px" onchange="updateNodeShape(${i},this.value)"><option value="rect" ${n.shape==='rect'?'selected':''}>â–¡</option><option value="round" ${n.shape==='round'?'selected':''}>â—‹</option><option value="diamond" ${n.shape==='diamond'?'selected':''}>â—‡</option></select><input type="text" class="builder-input" value="${n.text}" oninput="updateNodeText(${i},this.value)"><button class="btn-icon delete" onclick="removeNode(${i})"><i class="ph ph-trash"></i></button></div>`;
            });
            chartEdges.forEach((e, i) => {
                const ops = chartNodes.map(n => `<option value="${n.id}" ${n.id===e.from?'selected':''}>${n.text.substring(0,10)}...</option>`).join('');
                const opsTo = chartNodes.map(n => `<option value="${n.id}" ${n.id===e.to?'selected':''}>${n.text.substring(0,10)}...</option>`).join('');
                eList.innerHTML += `<div class="builder-row"><select class="builder-select" onchange="updateEdge(${i},'from',this.value)">${ops}</select><i class="ph ph-arrow-right" style="font-size:0.8rem"></i><select class="builder-select" onchange="updateEdge(${i},'to',this.value)">${opsTo}</select><input type="text" class="builder-input" value="${e.text||''}" placeholder="Lbl" oninput="updateEdge(${i},'text',this.value)"><button class="btn-icon delete" onclick="removeEdge(${i})"><i class="ph ph-trash"></i></button></div>`;
            });
        }
        function addChartNode(){ chartNodes.push({id:'N'+Date.now().toString().slice(-4),text:'New',shape:'rect'}); renderBuilderUI(); updateChartPreview(); }
        function removeNode(i){ const id=chartNodes[i].id; chartNodes.splice(i,1); chartEdges=chartEdges.filter(e=>e.from!==id&&e.to!==id); renderBuilderUI(); updateChartPreview(); }
        function updateNodeShape(i,v){ chartNodes[i].shape=v; updateChartPreview(); }
        function updateNodeText(i,v){ chartNodes[i].text=v; updateChartPreview(); }
        function addChartConnection(){ if(chartNodes.length>1) chartEdges.push({from:chartNodes[0].id,to:chartNodes[1].id,text:''}); renderBuilderUI(); updateChartPreview(); }
        function removeEdge(i){ chartEdges.splice(i,1); renderBuilderUI(); updateChartPreview(); }
        function updateEdge(i,k,v){ chartEdges[i][k]=v; updateChartPreview(); }
        async function updateChartPreview() { document.getElementById('chartPreview').innerHTML = `<div class="mermaid">${generateMermaidCode()}</div>`; try{ await mermaid.run({nodes:[document.querySelector('#chartPreview .mermaid')]}); }catch(e){} }
        function generateMermaidCode() {
            let c="graph TD\nclassDef default fill:#fff,stroke:#333,stroke-width:1px;\n";
            chartNodes.forEach(n=>{ let s="[",e="]"; if(n.shape==='round'){s="(";e=")";}if(n.shape==='diamond'){s="{";e="}";} c+=`${n.id}${s}"${n.text.replace(/"/g,"'")}"${e}\n`; });
            chartEdges.forEach(e=>{ c+=`${e.from} -->${e.text?`|"${e.text}"|`:''} ${e.to}\n`; }); return c;
        }
        async function confirmInsertChart() {
            const c = generateMermaidCode();
            const s = JSON.stringify({nodes: chartNodes, edges: chartEdges});
            if (editingChartElement) { 
                editingChartElement.dataset.source = c; editingChartElement.dataset.state = s; 
                let mermaidDiv = editingChartElement.querySelector('.mermaid');
                if (!mermaidDiv) { mermaidDiv = document.createElement('div'); mermaidDiv.className = 'mermaid'; editingChartElement.appendChild(mermaidDiv); }
                mermaidDiv.textContent = c; mermaidDiv.removeAttribute('data-processed'); 
                await mermaid.run({nodes: [mermaidDiv]}); closeBuilderModal(); return; 
            }
            restoreSelection(); 
            const w = document.createElement('div'); w.className = 'visual-block-wrapper mermaid-wrapper'; w.contentEditable = "false"; w.dataset.source = c; w.dataset.state = s; 
            const mermaidDiv = document.createElement('div'); mermaidDiv.className = 'mermaid'; mermaidDiv.textContent = c; w.appendChild(mermaidDiv);
            attachBlockControls(w); insertNodeAtCursor(w); wrapperAfter(w); await mermaid.run({nodes: [mermaidDiv]}); closeBuilderModal();
        }

        // --- CHART.JS ---
        let cjsInstance = null, cjsData = {type:'bar',title:'',label:'Data',points:[]}, editingCjsElement = null;

        function openChartJsModal(data=null) {
            saveSelection();
            builderModalContent.innerHTML = `
                <div class="builder-layout">
                    <div class="builder-panel">
                        <h3>Chart Builder</h3>
                        <p style="font-size:0.8rem; color:#666; margin-top:-10px;">Configure your dataset.</p>
                        <div class="builder-section">
                            <div class="builder-header">Settings</div>
                            <div class="builder-row">
                                <select id="cjsType" class="builder-select" onchange="updateChartJsPreview()">
                                    <option value="bar">Bar Chart</option>
                                    <option value="line">Line Chart</option>
                                    <option value="pie">Pie Chart</option>
                                    <option value="doughnut">Doughnut Chart</option>
                                </select>
                            </div>
                            <div class="builder-row"><input type="text" id="cjsTitle" class="builder-input" placeholder="Chart Title" oninput="updateChartJsPreview()"></div>
                            <div class="builder-row"><input type="text" id="cjsDatasetLabel" class="builder-input" placeholder="Dataset Label" value="Data" oninput="updateChartJsPreview()"></div>
                        </div>
                        <div class="builder-section">
                            <div class="builder-header">Data Points (Label | Value)</div>
                            <div id="cjsDataList"></div>
                            <button class="btn-add-item" onclick="addChartJsPoint()"><i class="ph ph-plus"></i> Add Point</button>
                        </div>
                        <div style="flex:1"></div>
                        <button class="btn-glass btn-glass-cancel" onclick="closeBuilderModal()">Cancel</button>
                    </div>
                    <div class="preview-panel">
                        <div class="chart-container-box"><canvas id="cjsPreviewCanvas"></canvas></div>
                        <div class="chart-actions"><button class="btn-glass btn-glass-insert active" onclick="confirmInsertChartJs()">Insert Chart</button></div>
                    </div>
                </div>`;
            builderModal.classList.add('active');
            if(data) cjsData=data; else cjsData={type:'bar',title:'',label:'Dataset',points:[{label:'A',value:10},{label:'B',value:20}]};
            document.getElementById('cjsType').value=cjsData.type; document.getElementById('cjsTitle').value=cjsData.title; document.getElementById('cjsDatasetLabel').value=cjsData.label; 
            renderChartJsBuilder(); updateChartJsPreview();
        }

        function renderChartJsBuilder() {
            const l=document.getElementById('cjsDataList'); if(!l) return; l.innerHTML=''; 
            cjsData.points.forEach((p,i)=>{ l.innerHTML+=`<div class="builder-row"><input class="builder-input" value="${p.label}" oninput="updateCjsPoint(${i},'label',this.value)"><input type="number" class="builder-input" value="${p.value}" oninput="updateCjsPoint(${i},'value',this.value)"><button class="btn-icon delete" onclick="removeCjsPoint(${i})"><i class="ph ph-trash"></i></button></div>`; });
        }
        function addChartJsPoint(){ cjsData.points.push({label:'New',value:0}); renderChartJsBuilder(); updateChartJsPreview(); }
        function removeCjsPoint(i){ cjsData.points.splice(i,1); renderChartJsBuilder(); updateChartJsPreview(); }
        function updateCjsPoint(i,k,v){ cjsData.points[i][k]=(k==='value')?parseFloat(v)||0:v; updateChartJsPreview(); }
        function getChartColors(n,t){ const c=['rgba(255,99,132,0.6)','rgba(54,162,235,0.6)','rgba(255,206,86,0.6)','rgba(75,192,192,0.6)','rgba(153,102,255,0.6)','rgba(255,159,64,0.6)']; const b=c.map(s=>s.replace('0.6','1')); if(t==='line') return {bg:c[1],bd:b[1]}; const bg=[],bd=[]; for(let i=0;i<n;i++){bg.push(c[i%6]);bd.push(b[i%6]);} return {bg,bd}; }
        function updateChartJsPreview() {
            const canvas = document.getElementById('cjsPreviewCanvas'); if(!canvas) return;
            cjsData.type=document.getElementById('cjsType').value; cjsData.title=document.getElementById('cjsTitle').value; cjsData.label=document.getElementById('cjsDatasetLabel').value;
            if(cjsInstance) cjsInstance.destroy(); const l=cjsData.points.map(p=>p.label), d=cjsData.points.map(p=>p.value), c=getChartColors(d.length,cjsData.type);
            const cfg={type:cjsData.type,data:{labels:l,datasets:[{label:cjsData.label,data:d,backgroundColor:c.bg,borderColor:c.bd,borderWidth:1,tension:0.1}]},options:{responsive:true,maintainAspectRatio:false,plugins:{title:{display:!!cjsData.title,text:cjsData.title},legend:{display:cjsData.type!=='bar'}}}};
            cjsInstance=new Chart(canvas,cfg);
        }
        function confirmInsertChartJs() {
            const l=cjsData.points.map(p=>p.label), d=cjsData.points.map(p=>p.value), c=getChartColors(d.length,cjsData.type);
            const cfg={type:cjsData.type,data:{labels:l,datasets:[{label:cjsData.label,data:d,backgroundColor:c.bg,borderColor:c.bd,borderWidth:1}]},options:{plugins:{title:{display:!!cjsData.title,text:cjsData.title}}}};
            if(cjsData.type==='line'){cfg.data.datasets[0].tension=0.1;cfg.data.datasets[0].fill=false;}
            const s=JSON.stringify(cjsData), e=JSON.stringify(cfg,null,2);
            if(editingCjsElement){ editingCjsElement.dataset.state=s; editingCjsElement.dataset.export=e; const cv=editingCjsElement.querySelector('canvas'); const ci=Chart.getChart(cv); if(ci)ci.destroy(); new Chart(cv,cfg); closeBuilderModal(); return; }
            restoreSelection(); const w=document.createElement('div'); w.className='visual-block-wrapper chart-wrapper'; w.contentEditable="false"; w.dataset.state=s; w.dataset.export=e; const cv=document.createElement('canvas'); cv.style.maxHeight="400px"; w.appendChild(cv); 
            attachBlockControls(w); insertNodeAtCursor(w); wrapperAfter(w); new Chart(cv,cfg); closeBuilderModal();
        }

        // --- DESMOS ---
        let calculator = null, editingDesmosElement = null;
        function openDesmosModal(state = null) {
            saveSelection();
            builderModalContent.innerHTML = `
                <div class="builder-layout full-layout">
                    <div style="flex:1; position:relative;">
                        <div id="desmosContainer"></div>
                        <div class="chart-actions">
                            <button class="btn-glass btn-glass-cancel" style="background: white; border:1px solid #ccc" onclick="closeBuilderModal()">Cancel</button>
                            <button class="btn-glass btn-glass-insert active" onclick="confirmInsertDesmos()">Insert Graph</button>
                        </div>
                    </div>
                </div>`;
            builderModal.classList.add('active');
            if(calculator) { calculator.destroy(); calculator=null; }
            calculator = Desmos.GraphingCalculator(document.getElementById('desmosContainer'), {settingsMenu:true,expressions:true});
            if(state) {
                if(state.config){ const c=state.config; if(c.bounds) calculator.setMathBounds({left:c.bounds.x[0],right:c.bounds.x[1],bottom:c.bounds.y[0],top:c.bounds.y[1]}); calculator.updateSettings({showGrid:c.grid!==false,showXAxis:c.showXAxis!==false,showYAxis:c.showYAxis!==false,xAxisLabel:c.xAxisLabel||'',yAxisLabel:c.yAxisLabel||''}); }
                if(state.expressions) calculator.setExpressions(state.expressions.map(l=>({latex:l})));
            } else calculator.setExpression({id:'1',latex:'y=x^2'});
        }
        function confirmInsertDesmos() {
            // 1. Get state immediately
            const s = calculator.getState();
            const b = calculator.graphpaperBounds.mathCoordinates;
            const st = calculator.graphSettings;
            const exprs = s.expressions.list.filter(e => e.type === 'expression' && e.latex).map(e => e.latex);
            const cfg = { bounds: { x: [b.left, b.right], y: [b.bottom, b.top] }, grid: st.showGrid, showXAxis: st.showXAxis, showYAxis: st.showYAxis, xAxisLabel: st.xAxisLabel, yAxisLabel: st.yAxisLabel };
            const json = JSON.stringify({ expressions: exprs, config: cfg });

            // 2. Visual Feedback (User knows to wait)
            const btn = document.querySelector('.btn-glass-insert.active');
            const originalText = btn ? btn.innerText : 'Insert Graph';
            if(btn) {
                btn.innerText = "Generating Preview...";
                btn.style.opacity = "0.7";
                btn.style.cursor = "wait";
            }

            // 3. Wait for render to finish before screenshotting
            // We wait 600ms to be safe. Desmos needs time to "paint".
            setTimeout(() => {
                const shot = calculator.screenshot({ width: 600, height: 400, targetPixelRatio: 2 });
                
                // Handle Edit Mode
                if (editingDesmosElement) {
                    editingDesmosElement.dataset.state = json;
                    editingDesmosElement.querySelector('img').src = shot;
                } else {
                    restoreSelection();
                    const w = document.createElement('div');
                    w.className = 'visual-block-wrapper desmos-wrapper';
                    w.contentEditable = "false";
                    w.dataset.state = json;
                    
                    const img = document.createElement('img');
                    img.src = shot;
                    img.style.width = '100%';
                    img.style.borderRadius = '8px';
                    w.appendChild(img);
                    
                    attachBlockControls(w);
                    insertNodeAtCursor(w);
                    wrapperAfter(w);
                }

                // --- FIX: FORCE SAVE NOW ---
                saveToLocal(true); 
                
                closeBuilderModal();
            }, 600);
        }

        // --- IMAGES ---
        function openImageModal() {
            saveSelection();
            const content = `
                <input type="text" class="glass-input" id="dynImgUrl" placeholder="Paste image URL here...">
                <div style="text-align:center; color:#888; margin: 10px 0;">OR</div>
                <div class="file-upload-wrapper">
                    <div class="btn-file-choice" onclick="document.getElementById('dynImgFile').click()">
                        <i class="ph ph-upload-simple" style="font-size:1.5rem"></i>
                        <span id="dynFileName">Click to upload from device</span>
                    </div>
                    <input type="file" id="dynImgFile" accept="image/*" style="display:none" onchange="document.getElementById('dynFileName').innerText = this.files[0].name">
                </div>
            `;

            const modal = spawnModal('Add Media', content, (overlay) => {
                const url = overlay.querySelector('#dynImgUrl').value;
                const fileInput = overlay.querySelector('#dynImgFile');
                
                restoreSelection();
                
                if (fileInput.files.length) {
                    const r = new FileReader();
                    r.onload = e => insertImageTag(e.target.result);
                    r.readAsDataURL(fileInput.files[0]);
                    return true;
                } else if (url.trim()) {
                    insertImageTag(url.trim());
                    return true;
                }
                return false;
            });
            
            // Focus URL input
            setTimeout(() => modal.querySelector('#dynImgUrl').focus(), 50);
        }
        function closeImageModal() { imgModal.classList.remove('active'); imgUrlInput.value=""; imgFileInput.value=""; document.getElementById('fileNameDisplay').innerText="Click to upload"; checkImgInput(); }
        function handleFileSelect() { if(imgFileInput.files.length) document.getElementById('fileNameDisplay').innerText=imgFileInput.files[0].name; checkImgInput(); }
        function checkImgInput() { btnInsertImg.classList.toggle('active', imgUrlInput.value.trim().length>0 || imgFileInput.files.length>0); }
        function confirmInsertImage() {
            restoreSelection(); if(imgFileInput.files.length){ const r=new FileReader(); r.onload=e=>insertImageTag(e.target.result); r.readAsDataURL(imgFileInput.files[0]); saveToLocal(true);} else if(imgUrlInput.value.trim()) { insertImageTag(imgUrlInput.value.trim()); saveToLocal(true); } closeImageModal();
        }

        function insertImageTag(src) { 
            const wrapper = document.createElement('div');
            wrapper.className = 'visual-block-wrapper type-image';
            wrapper.contentEditable = "false";
            
            const img = document.createElement('img'); 
            img.src = src; 
            
            wrapper.appendChild(img);
            attachBlockControls(wrapper); 
            
            insertNodeAtCursor(wrapper); 
            wrapperAfter(wrapper); 
        }

        function wrapperAfter(node) { const p=document.createElement('p'); p.innerHTML="<br>"; node.after(p); }

        editor.addEventListener('dblclick', (e) => {
            let t=e.target; while(t&&t!==editor){
                if(t.classList.contains('mermaid-wrapper')) { editingChartElement=t; return openFlowchartModal(JSON.parse(t.dataset.state)); }
                if(t.classList.contains('chart-wrapper')) { editingCjsElement=t; return openChartJsModal(JSON.parse(t.dataset.state)); }
                if(t.classList.contains('desmos-wrapper')) { editingDesmosElement=t; return openDesmosModal(JSON.parse(t.dataset.state)); }
                t=t.parentElement;
            }
        });

        // --- KEYBOARD DELETION (Text/Inline Only) ---
        editor.addEventListener('keydown', (e) => {
            // 1. Handle Selection Deletion (Range) - Fixes "Can't delete Desmos/Images"
            const s = window.getSelection();
            if ((e.key === 'Backspace' || e.key === 'Delete') && !s.isCollapsed) {
                // If selection is not empty, force a standard delete command.
                // This handles contentEditable="false" blocks better than default browser behavior sometimes.
                document.execCommand('delete');
                e.preventDefault();
                saveToLocal();
                return;
            }

            // 2. Handle Specific Inline Deletions (Cursor) - Existing Logic
            if (e.key === 'Backspace') {
                if (!s.rangeCount || !s.isCollapsed) return;
                const anchor = s.anchorNode; const offset = s.anchorOffset;
                if (anchor.nodeType === 3) { 
                    if (offset === 0 && anchor.previousSibling) {
                        const prev = anchor.previousSibling;
                        if (prev.nodeType === 1 && (prev.classList.contains('math-wrapper') || prev.classList.contains('code-wrapper'))) { 
                            e.preventDefault(); prev.remove(); saveToLocal(); return; 
                        }
                    }
                    // Fix for Zero-width space deletion handling
                    else if (offset === 1 && anchor.textContent.charCodeAt(0) === 8203 && anchor.previousSibling) {
                        const prev = anchor.previousSibling;
                        if (prev.nodeType === 1 && (prev.classList.contains('math-wrapper') || prev.classList.contains('code-wrapper'))) { 
                            e.preventDefault(); prev.remove(); anchor.textContent = ''; saveToLocal(); return; 
                        }
                    }
                }
            }
        });

        function insertMarkscheme() {
            const d = document.createElement('details'); d.className='markscheme'; d.open=true; d.contentEditable="false"; d.innerHTML=`<summary><span class="summary-title" contenteditable="true">Markscheme</span></summary><div class="markscheme-content" contenteditable="true"><p>Answer...</p></div>`; 
            attachBlockControls(d); insertNodeAtCursor(d); wrapperAfter(d); setTimeout(()=>d.querySelector('.summary-title').focus(),10);
        }

        // --- MARKDOWN IMPORT / EXPORT ---
        async function saveAsFile() {
            const markdown = parseToMarkdown(editor);
            const title = document.getElementById('docTitle').value || "Untitled Document";
            if (window.showSaveFilePicker) {
                try {
                    const handle = await window.showSaveFilePicker({ suggestedName: title + '.md', types: [{ description: 'Markdown File', accept: {'text/markdown': ['.md']} }] });
                    const writable = await handle.createWritable(); await writable.write(markdown); await writable.close();
                } catch (err) {}
            } else { downloadMarkdown(); }
        }

        function downloadMarkdown() {
            let t=docTitle.value.trim(); if(!t)t="Untitled Document";
            const blob=new Blob([parseToMarkdown(editor)], {type:'text/markdown'});
            const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=t.replace(/[^a-z0-9]/gi,'_').toLowerCase()+'.md'; a.click();
        }

        function importMarkdown(input) {
            const file = input.files[0]; // 1. Capture file immediately
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                // 2. Use the captured 'file' variable, not 'input.files[0]'
                const fileName = file.name.replace(/\.md$/i, '');
                document.getElementById('docTitle').value = fileName;
                document.getElementById('miniTitleInput').value = fileName;

                editor.innerHTML = ''; 
                const text = e.target.result;
                const lines = text.split('\n');
                
                // ... (Variables state remains the same) ...
                let inCodeBlock = false, codeType = '', codeBuffer = [];
                let inMarkscheme = false, markschemeBuffer = [];
                let inMathBlock = false, mathBuffer = [];
                let inTable = false; let tableBuffer = [];
                let inList = false; let currentListType = null; let listContainer = null;

                for (let i=0; i<lines.length; i++) {
                    let line = lines[i];
                    
                    // Table Detection
                    if (line.trim().startsWith('|')) { inTable = true; tableBuffer.push(line); continue; } 
                    else if (inTable) { processTableBlock(tableBuffer); inTable = false; tableBuffer = []; }

                    // Task List Detection (- [ ] or - [x])
                    const taskMatch = line.match(/^-\s\[([ xX])\]\s+(.*)/);
                    if (taskMatch) {
                        const isChecked = (taskMatch[1].toLowerCase() === 'x');
                        const content = taskMatch[2];
                        
                        if (!inList || currentListType !== 'task') {
                            listContainer = document.createElement('ul');
                            listContainer.className = 'task-list';
                            editor.appendChild(listContainer);
                            currentListType = 'task';
                            inList = true;
                        }
                        
                        const li = document.createElement('li');
                        if(isChecked) li.classList.add('checked');
                        processTextLine(content, li);
                        listContainer.appendChild(li);
                        continue;
                    } 

                    // Standard List Detection
                    const ulMatch = line.match(/^(\*|-)\s+(.*)/);
                    const olMatch = line.match(/^(\d+)\.\s+(.*)/);

                    if (ulMatch || olMatch) {
                        const type = ulMatch ? 'ul' : 'ol';
                        const content = ulMatch ? ulMatch[2] : olMatch[2];
                        
                        if (!inList || currentListType !== type) { 
                            listContainer = document.createElement(type); 
                            editor.appendChild(listContainer); 
                            currentListType = type; 
                            inList = true; 
                        }
                        const li = document.createElement('li'); 
                        processTextLine(content, li); 
                        listContainer.appendChild(li);
                        continue;
                    } else { inList = false; listContainer = null; }

                    // Code Blocks
                    if (line.trim().startsWith('```')) {
                        if (inCodeBlock) { await processCodeBlock(codeType, codeBuffer.join('\n')); inCodeBlock = false; codeBuffer = []; codeType = ''; } 
                        else { if(inList) { inList = false; listContainer = null; } inCodeBlock = true; codeType = line.trim().replace('```', '').trim(); }
                        continue;
                    }
                    if (inCodeBlock) { codeBuffer.push(line); continue; }

                    // Math Blocks
                    if (line.trim() === '$$') {
                        if (inMathBlock) {
                            const mathContent = mathBuffer.join('\n'); const isChem = mathContent.trim().startsWith('\\ce{');
                            const val = isChem ? mathContent.trim().slice(4, -1) : mathContent.trim();
                            const div = document.createElement('div'); div.className='block-container'; div.contentEditable="false";
                            const mf = new MathfieldElement(); mf.value = val; mf.mathVirtualKeyboardPolicy="manual"; 
                            mf.classList.add(isChem ? 'chem-field' : 'math-field'); if(isChem) mf.setAttribute('letter-shape-style','upright');
                            div.appendChild(mf); attachBlockControls(div); editor.appendChild(div); editor.appendChild(document.createElement('br'));
                            inMathBlock = false; mathBuffer = [];
                        } else { if(inList) { inList = false; listContainer = null; } inMathBlock = true; }
                        continue;
                    }
                    if (inMathBlock) { mathBuffer.push(line); continue; }

                    // Markscheme
                    if (line.trim() === '<details>') { inMarkscheme = true; if(inList){inList=false; listContainer=null;} continue; }
                    if (line.trim() === '</details>') { processMarkscheme(markschemeBuffer); inMarkscheme = false; markschemeBuffer = []; continue; }
                    if (inMarkscheme) { markschemeBuffer.push(line); continue; }

                    // Subtitles
                    if (line.trim().startsWith('<small>')) {
                        const sm = document.createElement('small');
                        sm.innerText = line.replace(/<\/?small>/g, '');
                        editor.appendChild(sm);
                        continue;
                    }
                    
                    processTextLine(line);
                }

                if (inTable && tableBuffer.length > 0) { processTableBlock(tableBuffer); }

                saveToLocal();
                hydrateDOM();
            };
            
            reader.readAsText(file);
            input.value = ''; // Clear after reading starts
        }

        async function processCodeBlock(type, code) {
            const p = document.createElement('p'); p.innerHTML='<br>';
            if (type === 'mermaid') {
                const lines = code.split('\n'); let mermaidCode = ""; let jsonState = JSON.stringify({nodes:[], edges:[]}); 
                lines.forEach(l => { if(l.startsWith('%% state:')) { try { jsonState = l.replace('%% state:', '').trim(); } catch(e){} } else { mermaidCode += l + "\n"; } });
                const w = document.createElement('div'); w.className = 'visual-block-wrapper mermaid-wrapper'; w.contentEditable = "false"; w.dataset.source = mermaidCode; w.dataset.state = jsonState;
                const mermaidDiv = document.createElement('div'); mermaidDiv.className = 'mermaid'; mermaidDiv.textContent = mermaidCode; 
                w.appendChild(mermaidDiv); attachBlockControls(w); editor.appendChild(w); editor.appendChild(p); 
                await mermaid.run({nodes:[mermaidDiv]});
            }
            else if (type === 'chart') {
                const config = JSON.parse(code); const data = config.data;
                const points = data.labels.map((l,i) => ({ label:l, value: data.datasets[0].data[i] }));
                const state = { type: config.type, title: config.options.plugins.title.text, label: data.datasets[0].label, points: points };
                const w = document.createElement('div'); w.className='visual-block-wrapper chart-wrapper'; w.contentEditable="false"; w.dataset.state=JSON.stringify(state); w.dataset.export=code;
                const cv = document.createElement('canvas'); cv.style.maxHeight="400px"; w.appendChild(cv);
                attachBlockControls(w); editor.appendChild(w); editor.appendChild(p); new Chart(cv, config);
            }
            else if (type === 'desmos') {
                const lines = code.split('\n'); let config = {}, exprs = [];
                lines.forEach(l => { if(l.startsWith('//config:')) { try { config = JSON.parse(l.replace('//config:', '')); } catch(e){} } else if(l.trim()) exprs.push(l.trim()); });
                
                const state = { config: config, expressions: exprs };
                const w = document.createElement('div'); w.className='visual-block-wrapper desmos-wrapper'; w.contentEditable="false"; w.dataset.state=JSON.stringify(state);
                
                // Placeholder image while loading
                const img = document.createElement('img'); 
                img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 400' style='background:%23eee'%3E%3Ctext x='50%25' y='50%25' dominant-baseline='middle' text-anchor='middle' font-family='sans-serif' fill='%23aaa'%3EGenerating Graph...%3C/text%3E%3C/svg%3E";
                img.style.width='100%'; img.style.borderRadius='8px'; w.appendChild(img);
                
                attachBlockControls(w); editor.appendChild(w); editor.appendChild(p);
                
                // --- FIX: Robust Screenshot Generation ---
                // We use a slight delay loop to ensure the DOM has placed the elements
                setTimeout(async () => {
                    const tempContainer = document.getElementById('tempCalculator');
                    // Reset container
                    tempContainer.innerHTML = '';
                    tempContainer.style.width = "600px"; 
                    tempContainer.style.height = "400px";
                    
                    const tempCalc = Desmos.GraphingCalculator(tempContainer, {expressions:false, actions: false});
                    if(config.bounds) tempCalc.setMathBounds({left:config.bounds.x[0], right:config.bounds.x[1], bottom:config.bounds.y[0], top:config.bounds.y[1]});
                    
                    // Set expressions
                    tempCalc.setExpressions(exprs.map(e=>({latex:e})));

                    // Wait 1 FULL SECOND for Desmos to calculate lines in the background
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // Take screenshot and update the image
                    img.src = tempCalc.screenshot({width:600, height:400, targetPixelRatio:2});
                    tempCalc.destroy();
                    
                    // Trigger a save to local storage so the image persists
                    saveToLocal();
                }, 100);
            }
            else {
                const wrapper = document.createElement('div'); wrapper.className = "code-block-wrapper"; wrapper.contentEditable = "false";
                const pre = document.createElement('pre'); pre.contentEditable = "true"; pre.innerText = code;
                wrapper.appendChild(pre); attachBlockControls(wrapper); editor.appendChild(wrapper); editor.appendChild(p);
            }
        }

        function processMarkscheme(lines) {
            let title = "Markscheme"; let contentLines = [];
            lines.forEach(l => { if (l.trim().startsWith('<summary>')) title = l.replace(/<\/?summary>/g, '').trim(); else if (l.trim() !== '') contentLines.push(l); });
            const d = document.createElement('details'); d.className='markscheme'; d.open=true; d.contentEditable="false";
            const sum = document.createElement('summary'); const tSpan = document.createElement('span'); tSpan.className='summary-title'; tSpan.contentEditable="true"; tSpan.innerText = title;
            sum.appendChild(tSpan); const content = document.createElement('div'); content.className='markscheme-content'; content.contentEditable="true";
            d.appendChild(sum); d.appendChild(content); attachBlockControls(d); editor.appendChild(d); editor.appendChild(document.createElement('br'));
            contentLines.forEach(line => processTextLine(line, content));
        }

        function processTextLine(line, parent = editor) {
            if (!line.trim()) return;

            // --- FIX: Unescape Markdown Characters ---
            // Converts "\." back to "." and "\-" back to "-" etc.
            line = line.replace(/\\([.\-*#_])/g, '$1');

            // Headers
            if (line.startsWith('# ')) { const h=document.createElement('h1'); h.innerText=line.slice(2); parent.appendChild(h); return; }
            if (line.startsWith('## ')) { const h=document.createElement('h2'); h.innerText=line.slice(3); parent.appendChild(h); return; }
            if (line.startsWith('### ')) { const h=document.createElement('h3'); h.innerText=line.slice(4); parent.appendChild(h); return; }
            if (line.startsWith('#### ')) { const h=document.createElement('h4'); h.innerText=line.slice(4); parent.appendChild(h); return; }
            if (line.startsWith('##### ')) { const h=document.createElement('h5'); h.innerText=line.slice(4); parent.appendChild(h); return; }

            // Blockquote
            if (line.startsWith('> ')) {
                const wrapper = document.createElement('div'); wrapper.className = "quote-wrapper"; wrapper.contentEditable = "false";
                const bq = document.createElement('blockquote'); bq.contentEditable = "true"; bq.innerText = line.slice(2);
                wrapper.appendChild(bq); attachBlockControls(wrapper); parent.appendChild(wrapper); return;
            }

            // Images
            const imgMatch = line.match(/!\[.*\]\((.*)\)/);
            if (imgMatch) { 
                const wrapper = document.createElement('div');
                wrapper.className = 'visual-block-wrapper type-image'; // <--- Key Class
                wrapper.contentEditable = "false";
                const img = document.createElement('img'); 
                img.src = imgMatch[1]; 
                wrapper.appendChild(img);
                attachBlockControls(wrapper); 
                parent.appendChild(wrapper); 
                parent.appendChild(document.createElement('br')); 
                return; 
            }

            // ... (Rest of the function remains the same as previous step) ...
            // Make sure you use the version from the previous step that handles bold/italic/links correctly!
            const p = (parent.tagName === 'LI') ? parent : document.createElement('p');
            
            // Escape placeholders
            let temp = line.replace(/\\\\/g, "___BS___").replace(/\\\*/g, "___AST___").replace(/\\_/g, "___US___");

            const parts = temp.split(/(`[^`]+`|\$[^$]+\$|\[.*?\]\(.*?\))/g);
            
            parts.forEach(part => {
                if (part.startsWith('$') && part.endsWith('$')) {
                    const latex = part.slice(1, -1).replace(/___BS___/g, "\\").replace(/___AST___/g, "*").replace(/___US___/g, "_");
                    const isChem = latex.startsWith('\\ce{'); const val = isChem ? latex.slice(4, -1) : latex;
                    const sp = document.createElement('span'); sp.className='math-wrapper'; sp.contentEditable="false";
                    const mf = new MathfieldElement(); mf.value=val; mf.mathVirtualKeyboardPolicy="manual"; mf.classList.add(isChem?'chem-field':'math-field'); if(isChem) mf.setAttribute('letter-shape-style','upright');
                    sp.appendChild(mf); p.appendChild(document.createTextNode('\u200B')); p.appendChild(sp); p.appendChild(document.createTextNode('\u200B'));
                } 
                else if (part.startsWith('`') && part.endsWith('`')) {
                    const codeText = part.slice(1, -1).replace(/___BS___/g, "\\").replace(/___AST___/g, "*").replace(/___US___/g, "_");
                    const wrapper = document.createElement('span'); wrapper.className = 'code-wrapper'; wrapper.contentEditable = "false";
                    const codeSpan = document.createElement('span'); codeSpan.className = 'inline-code'; codeSpan.contentEditable = "true"; codeSpan.innerText = codeText;
                    wrapper.appendChild(codeSpan); p.appendChild(document.createTextNode('\u200B')); p.appendChild(wrapper); p.appendChild(document.createTextNode('\u200B'));
                }
                else if (part.startsWith('[') && part.includes('](') && part.endsWith(')')) {
                    const match = part.match(/\[(.*?)\]\((.*?)\)/);
                    if (match) {
                        const a = document.createElement('a');
                        a.innerText = match[1];
                        a.href = match[2];
                        a.target = "_blank"; a.contentEditable = "false";
                        p.appendChild(a);
                    }
                }
                else {
                    let html = part;
                    html = html.replace(/\*\*(.*?)\*\*/g, "<b>$1</b>");
                    html = html.replace(/\*(.*?)\*/g, "<i>$1</i>");
                    html = html.replace(/~~(.*?)~~/g, "<s>$1</s>"); 
                    html = html.replace(/___BS___/g, "\\").replace(/___AST___/g, "*").replace(/___US___/g, "_");
                    const span = document.createElement('span'); 
                    span.innerHTML = html; 
                    p.appendChild(span);
                }
            });
            
            if (parent.tagName !== 'LI') parent.appendChild(p);
        }

        function parseToMarkdown(element) {
            let md = "";
            element.childNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE) {
                    md += node.textContent.replace(/\u200B/g, '').replace(/([\\*_{}[\]()#+\-.!])/g, '\\$1');
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Ignore UI Elements
                    if (node.classList.contains('btn-block-delete') || 
                        node.classList.contains('table-controls-x') || 
                        node.classList.contains('table-controls-y') ||
                        node.classList.contains('table-actions-bar') || 
                        node.classList.contains('drag-handle')) {
                        return;
                    }
                    
                    const tag = node.tagName.toLowerCase();
                    const style = window.getComputedStyle(node);
                    let prefix = "", suffix = "";

                    // Inline Styles
                    if (tag === 'b' || tag === 'strong' || parseInt(style.fontWeight) > 600) { prefix += "<b>"; suffix = "</b>" + suffix; }
                    if (tag === 'i' || tag === 'em' || style.fontStyle === 'italic') { prefix += "<i>"; suffix = "</i>" + suffix; }
                    if (tag === 'u' || style.textDecorationLine.includes('underline')) { prefix += "<u>"; suffix = "</u>" + suffix; }
                    if (tag === 's' || tag === 'strike' || tag === 'del' || style.textDecorationLine.includes('line-through')) { prefix += "~~"; suffix = "~~" + suffix; }

                    // Links
                    if (tag === 'a') {
                        md += `[${parseToMarkdown(node)}](${node.getAttribute('href')})`;
                        return; 
                    }

                    // Task Lists
                    if (tag === 'ul' && node.classList.contains('task-list')) {
                        md += "\n";
                        node.childNodes.forEach(li => {
                            if (li.tagName === 'LI') {
                                const mark = li.classList.contains('checked') ? 'x' : ' ';
                                md += `- [${mark}] ${parseToMarkdown(li).trim()}\n`;
                            }
                        });
                        md += "\n";
                        return; 
                    }

                    // Normal Lists
                    else if (tag === 'ul') { md += "\n"; node.childNodes.forEach(li => { md += `* ${parseToMarkdown(li).trim()}\n`; }); md += "\n"; }
                    else if (tag === 'ol') { md += "\n"; let idx = 1; node.childNodes.forEach(li => { md += `${idx}. ${parseToMarkdown(li).trim()}\n`; idx++; }); md += "\n"; }
                    
                    // Headers
                    else if (tag === 'h1') md += `\n# ${node.textContent}\n`;
                    else if (tag === 'h2') md += `\n## ${node.textContent}\n`;
                    else if (tag === 'h3') md += `\n### ${node.textContent}\n`;
                    else if (tag === 'h4') md += `\n#### ${node.textContent}\n`;
                    else if (tag === 'h5') md += `\n##### ${node.textContent}\n`;
                    else if (tag === 'small') md += `\n<small>${node.innerText}</small>\n`;

                    // Standard Blocks
                    else if (node.classList.contains('quote-wrapper')) { const bq = node.querySelector('blockquote'); if (bq) md += `\n> ${bq.innerText.trim()}\n`; }
                    else if (node.classList.contains('code-block-wrapper')) { const pre = node.querySelector('pre'); if (pre) md += `\n\`\`\`\n${pre.innerText}\n\`\`\`\n`; }
                    else if (node.classList.contains('code-wrapper')) md += " `" + node.innerText + "` ";
                    
                    // --- FIX: Image Export ---
                    // Explicitly handle the visual wrapper if it contains an image
                    else if (node.classList.contains('visual-block-wrapper') && node.classList.contains('type-image')) {
                        const img = node.querySelector('img');
                        if (img) md += `\n![Image](${img.src})\n`;
                    }
                    // Fallback for orphan images (not wrapped)
                    else if (tag === 'img' && !node.closest('.visual-block-wrapper')) {
                        md += `\n![Image](${node.src})\n`;
                    }

                    // Visual Blocks (Mermaid/Chart/Desmos)
                    else if (node.classList.contains('mermaid-wrapper')) { md += `\n\`\`\`mermaid\n${node.dataset.source}\n%% state: ${node.dataset.state}\n\`\`\`\n`; }
                    else if (node.classList.contains('chart-wrapper')) { md += `\n\`\`\`chart\n${node.dataset.export}\n\`\`\`\n`; }
                    else if (node.classList.contains('desmos-wrapper')) { 
                        const s = JSON.parse(node.dataset.state); 
                        md += `\n\`\`\`desmos\n//config: ${JSON.stringify(s.config)}\n${s.expressions.join('\n')}\n\`\`\`\n`; 
                    }
                    
                    // Math
                    else if (tag === 'math-field') { 
                        const l = node.value; const isChem = node.classList.contains('chem-field'); const isB = node.parentElement.classList.contains('block-container');
                        const c = isChem ? `\\ce{${l}}` : l; md += isB ? `\n$$\n${c}\n$$\n` : `$${c}$`; 
                    }
                    else if (node.classList.contains('math-wrapper')) md += parseToMarkdown(node);
                    else if (tag === 'details') md += `\n<details>\n<summary>${node.querySelector('.summary-title').innerText}</summary>\n\n${parseToMarkdown(node.querySelector('.markscheme-content'))}\n</details>\n`;
                    
                    // Tables
                    else if (tag === 'table' || (node.classList.contains('table-wrapper'))) {
                        const table = (tag === 'table') ? node : node.querySelector('table');
                        if (table) {
                            const rows = Array.from(table.querySelectorAll('tr')); md += "\n";
                            rows.forEach((row, index) => {
                                const cells = Array.from(row.querySelectorAll('th, td'));
                                const rowText = "| " + cells.map(c => c.innerText.trim()).join(" | ") + " |";
                                md += rowText + "\n";
                                if (index === 0) { const separator = "| " + cells.map(() => "---").join(" | ") + " |"; md += separator + "\n"; }
                            }); md += "\n";
                        }
                    }
                    // Standard Text Blocks (Recursive)
                    else if (tag === 'p' || tag === 'div') { 
                        if (node.classList.contains('block-container')) md += parseToMarkdown(node); 
                        else md += `\n${parseToMarkdown(node)}\n`; 
                    }
                    else if (tag === 'br') md += "\n";
                    else if (tag === 'li') md += parseToMarkdown(node); 
                    
                    else md += prefix + parseToMarkdown(node) + suffix;
                }
            });
            return md;
        }


        function createNewDoc(force = false) {
            // 1. Generate a new ID but DO NOT save it to localStorage yet
            currentDocId = 'doc_' + Date.now();
            localStorage.setItem('current_id', currentDocId);
            
            // 2. Clear UI
            document.getElementById('docTitle').value = "";
            document.getElementById('miniTitleInput').value = "";
            document.getElementById('styleLabel').innerText = "Normal";
            editor.innerHTML = "<h1>Markdown Editor</h1><p>Start typing here...</p>";
            
            // 3. UI Cleanup
            const fileModal = document.getElementById('fileModal');
            if(fileModal) fileModal.classList.remove('active');
            toggleScrollLock(false); // Unlock background
            
            document.getElementById('docTitle').focus();
            checkFormatState();
            
            if (force) { saveToLocal(true); } 
            // The file will only be saved when the user actually types (via MutationObserver).
        }

        function deleteDoc(id) { 
            showDialog("Delete File?", "Are you sure you want to delete this file?", "warning", () => {
                let allDocs = JSON.parse(localStorage.getItem('docs') || '{}'); 
                delete allDocs[id]; 
                localStorage.setItem('docs', JSON.stringify(allDocs)); 

                if (id === currentDocId) {
                    // Wipe the screen but don't save a new entry yet
                    createNewDoc();
                }
                openFileManager(); 
            });
        }

        // --- NEW: Dark Mode Logic ---
        function toggleDarkMode() {
            const isDark = document.getElementById('darkModeToggle').checked;
            if (isDark) {
                document.body.classList.add('dark-mode');
                localStorage.setItem('dark_mode', 'true');
            } else {
                document.body.classList.remove('dark-mode');
                localStorage.setItem('dark_mode', 'false');
            }
        }

        // --- NEW: Help Logic ---
        function openHelp() {
            const helpText = `
                <p><strong>Shortcuts:</strong></p>
                <ul>
                    <li><b>Ctrl+B / I / U</b>: Bold, Italic, Underline</li>
                    <li><b>Type "- "</b>: Starts a bullet list</li>
                    <li><b>Type "1. "</b>: Starts a numbered list</li>
                    <li><b>Type "> "</b>: Creates a blockquote</li>
                    <li><b>Type "# "</b>: Creates a Heading 1</li>
                </ul>
                <p><strong>Features:</strong></p>
                <ul>
                    <li><b>Math:</b> Use the toolbar to insert Block or Inline math. Supports LaTeX.</li>
                    <li><b>Charts:</b> Insert Bar, Line, Pie charts via the Insert menu.</li>
                    <li><b>Desmos:</b> Insert fully functional graphing calculator snapshots.</li>
                    <li><b>Flowcharts:</b> Use the Mermaid builder to create diagrams.</li>
                    <li><b>Markschemes:</b> Create expandable details blocks for answers.</li>
                </ul>
                <p><strong>Saving:</strong></p>
                <p>Your work is saved automatically to your browser's Local Storage. You can also export to .md files.</p>
                <p><strong>Credits:</strong></p>
                <p>This document editor uses open-source libraries including Chart.js, Desmos, Mermaid, and MathLive.</p>
                <p style="font-size: 0.7rem;">
                âš ï¸ DESMOS API DISCLAIMER â€“ REQUIRED NOTICE âš ï¸<br>

                This project references or utilizes elements of the Desmos Graphing Calculator or its API. Please be aware of the following critical usage restrictions:<br><br>

                1. Desmos does NOT offer public or open access to their API. Any integration beyond their public graphing calculator embed must be explicitly approved through Desmosâ€™s official Partnership Program.<br><br>

                2. API keys and advanced features (e.g., programmatic graph creation, data syncing, deep integrations) require PRIOR authorization.<br>

                3. Unauthorized use of the Desmos APIâ€”including accessing endpoints without permission, reverse engineering, scraping, or automated accessâ€”is strictly forbidden and may violate Desmosâ€™s Terms of Service.<br><br>

                4. If you wish to use the Desmos API legally and safely, you MUST:<br>
                - Apply at https://www.desmos.com/partners<br>
                - Receive approval and credentials from Desmos, Inc.<br>
                - Follow all relevant documentation and branding guidelines<br><br>

                5. This project is NOT affiliated with or endorsed by Desmos, Inc. All trademarks and services belong to their respective owners.<br>

                Failure to comply with these terms can result in:<br>
                - API access revocation<br>
                - Legal action<br>
                - Application malfunction or incompatibility<br>
                - User data loss or privacy violations<br><br>

                ðŸ”— Official API access: https://www.desmos.com/partners<br>
                ðŸ”— Terms of Service: https://www.desmos.com/terms<br>
                ðŸ”— Privacy Policy: https://www.desmos.com/privacy<br><br>

                DO NOT use the Desmos API in production or distributed applications without explicit permission from Desmos.</p>
            `;
            document.getElementById('helpContent').innerHTML = helpText;
            document.getElementById('helpModal').classList.add('active');
        }
        function clearAllStorage() {
            // --- UPDATED: Use Custom Dialog ---
            showDialog("Clear Everything?", "WARNING: This will permanently delete ALL your saved files and settings. This action cannot be undone.", "warning", () => {
                localStorage.clear();
                location.reload();
            });
        }

        // --- Custom Dialog Logic ---
        let currentDialogCallback = null;

        function showDialog(title, msg, type = 'alert', callback = null) {
            document.getElementById('dialogTitle').innerText = title;
            document.getElementById('dialogMsg').innerText = msg;
            
            const icon = document.getElementById('dialogIcon');
            const btnCancel = document.getElementById('dialogBtnCancel');
            const btnConfirm = document.getElementById('dialogBtnConfirm');
            
            // Reset Styles
            icon.className = 'dialog-icon';
            icon.innerHTML = '<i class="ph ph-info"></i>';
            btnConfirm.className = 'btn-glass btn-glass-insert active';
            btnConfirm.style.background = 'var(--primary)';
            
            currentDialogCallback = callback;

            if (type === 'confirm' || type === 'warning') {
                btnCancel.style.display = 'block';
                btnConfirm.innerText = 'Yes';
                
                if(type === 'warning') {
                    icon.classList.add('warning');
                    icon.innerHTML = '<i class="ph ph-warning"></i>';
                    btnConfirm.style.background = 'var(--danger)';
                } else {
                    icon.innerHTML = '<i class="ph ph-question"></i>';
                }
            } else {
                // Alert Mode
                btnCancel.style.display = 'none';
                btnConfirm.innerText = 'OK';
                icon.innerHTML = '<i class="ph ph-check-circle"></i>';
            }

            document.getElementById('dialogModal').classList.add('active');
        }

        function closeDialog(isConfirmed) {
            document.getElementById('dialogModal').classList.remove('active');
            if (currentDialogCallback && isConfirmed) {
                currentDialogCallback();
            }
            currentDialogCallback = null;
        }

        // Wrapper to handle click on the dropdown item vs the slider
        function toggleDarkModeWrapper(e) {
            // Prevent triggering if clicking the label directly (let checkbox handle it)
            if(e.target.tagName === 'INPUT' || e.target.classList.contains('slider')) {
                toggleDarkMode();
                return;
            }
            // If clicking the row text, toggle the checkbox manually
            const cb = document.getElementById('darkModeToggle');
            cb.checked = !cb.checked;
            toggleDarkMode();
        }

                // --- GLOBAL TABLE CONTEXT ---
        // Tracks the currently active table and cell coordinates
        let activeTableCtx = {
            wrapper: null,
            rowIdx: -1, // -1 means "Default/End"
            colIdx: -1
        };


        // --- EVENT LISTENERS FOR TABLE CONTEXT ---
        document.addEventListener('keyup', (e) => handleTableFocusChange(e));
        document.addEventListener('mouseup', (e) => handleTableFocusChange(e));

        function handleTableFocusChange(e) {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            
            let node = sel.anchorNode;
            // Bubble up to find TD/TH
            while (node && node.tagName !== 'TD' && node.tagName !== 'TH' && node !== editor) {
                node = node.parentElement;
            }

            // 1. User is inside a TD (Body Cell)
            if (node && node.tagName === 'TD') {
                const wrapper = node.closest('.table-wrapper');
                const table = wrapper.querySelector('table');
                const tr = node.parentElement;
                
                activeTableCtx = {
                    wrapper: wrapper,
                    rowIdx: tr.rowIndex,
                    colIdx: node.cellIndex
                };
                
                wrapper.classList.add('active-focus');
                positionTableControls(wrapper, node);
            } 
            // 2. User is inside TH or Table Wrapper but not TD -> Default Position
            else if (node && (node.tagName === 'TH' || node.closest('.table-wrapper'))) {
                const wrapper = node.closest('.table-wrapper');
                resetTableControls(wrapper);
            }
            // 3. User clicked outside -> Reset everything
            else {
                document.querySelectorAll('.table-wrapper').forEach(w => {
                    w.classList.remove('active-focus');
                    // Reset positions visually to default
                    const cx = w.querySelector('.table-controls-x');
                    const cy = w.querySelector('.table-controls-y');
                    if(cx) { cx.style.left = '0'; cx.style.width = '100%'; cx.style.transform = 'none'; }
                    if(cy) { cy.style.top = '0'; cy.style.height = '100%'; cy.style.transform = 'none'; }
                });
                activeTableCtx = { wrapper: null, rowIdx: -1, colIdx: -1 };
            }
        }

        function positionTableControls(wrapper, cell) {
            const cx = wrapper.querySelector('.table-controls-x');
            const cy = wrapper.querySelector('.table-controls-y');

            // Calculate position relative to the wrapper
            const cellRect = cell.getBoundingClientRect();
            const wrapperRect = wrapper.getBoundingClientRect();

            const relativeLeft = cellRect.left - wrapperRect.left;
            const relativeTop = cellRect.top - wrapperRect.top;

            // Move Column Controls (Bottom) to align with this column
            if (cx) {
                cx.style.width = `${cell.offsetWidth}px`;
                cx.style.left = `${relativeLeft}px`;
                // Reset transform from default state
                cx.style.transform = 'none'; 
            }

            // Move Row Controls (Right) to align with this row
            if (cy) {
                cy.style.height = `${cell.offsetHeight}px`;
                cy.style.top = `${relativeTop}px`;
                cy.style.transform = 'none';
            }
        }

        function resetTableControls(wrapper) {
            if (!wrapper) return;
            activeTableCtx = { wrapper: wrapper, rowIdx: -1, colIdx: -1 }; // -1 indicates "Target End"
            
            wrapper.classList.remove('active-focus');

            const cx = wrapper.querySelector('.table-controls-x');
            const cy = wrapper.querySelector('.table-controls-y');

            // Default X: Centered width, at bottom
            if (cx) {
                cx.style.width = '100%';
                cx.style.left = '0';
            }

            // Default Y: Centered height, at right
            if (cy) {
                cy.style.height = '100%';
                cy.style.top = '0';
            }
        }

        function insertTable(rows = 2, cols = 3) {
            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.contentEditable = "false"; 

            // Delete Table Button (Top Right)
            attachBlockControls(wrapper);

            // Row Controls (Y-axis - Right Side)
            const controlsY = document.createElement('div');
            controlsY.className = 'table-controls-y';
            controlsY.contentEditable = "false";
            controlsY.innerHTML = `
                <button class="btn-mini-control" onclick="modifyTable(this, 'row-add')" title="Insert Row Below"><i class="ph ph-arrow-down"></i></button>
                <button class="btn-mini-control danger" onclick="modifyTable(this, 'row-del')" title="Delete Row"><i class="ph ph-trash"></i></button>
            `;

            // Col Controls (X-axis - Bottom)
            const controlsX = document.createElement('div');
            controlsX.className = 'table-controls-x';
            controlsX.contentEditable = "false";
            controlsX.innerHTML = `
                <button class="btn-mini-control" onclick="modifyTable(this, 'col-add')" title="Insert Column Right"><i class="ph ph-arrow-right"></i></button>
                <button class="btn-mini-control danger" onclick="modifyTable(this, 'col-del')" title="Delete Column"><i class="ph ph-trash"></i></button>
            `;

            wrapper.appendChild(controlsY);
            wrapper.appendChild(controlsX);

            // Create Table Structure
            const table = document.createElement('table');
            table.contentEditable = "true";
            
            // Header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            for(let i=0; i<cols; i++) {
                const th = document.createElement('th'); th.innerText = `Header`; headerRow.appendChild(th);
            }
            thead.appendChild(headerRow); table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            for(let i=0; i<rows; i++) {
                const tr = document.createElement('tr');
                for(let j=0; j<cols; j++) {
                    const td = document.createElement('td'); td.innerText = `Cell`; tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);
            wrapper.appendChild(table);

            insertNodeAtCursor(wrapper);
            wrapperAfter(wrapper);
            
            // Initialize default state
            resetTableControls(wrapper);
        }

        // --- MODIFIED MODIFY TABLE ---
        function modifyTable(btn, action) {
            // Determine context: Did we click the button while a cell was active?
            const wrapper = btn.closest('.table-wrapper');
            const table = wrapper.querySelector('table');
            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead');
            
            // If the button clicked belongs to the wrapper stored in context, use specific indices
            // Otherwise fall back to -1 (End)
            let rIdx = -1;
            let cIdx = -1;

            if (activeTableCtx.wrapper === wrapper) {
                rIdx = activeTableCtx.rowIdx;
                cIdx = activeTableCtx.colIdx;
            }

            // --- ROW OPERATIONS ---
            if (action === 'row-add') {
                const colCount = thead.rows[0].cells.length;
                const newTr = document.createElement('tr');
                for(let i=0; i<colCount; i++) { 
                    const td = document.createElement('td'); 
                    td.innerText = "Cell"; 
                    newTr.appendChild(td); 
                }

                // If specific row selected (and not header), insert AFTER it
                if (rIdx > 0 && rIdx <= tbody.rows.length) {
                    // tbody rows are 0-indexed relative to tbody
                    // rIdx is rowIndex relative to table (includes header)
                    // So active row in tbody is rIdx - 1
                    const refRow = tbody.rows[rIdx - 1];
                    if (refRow.nextSibling) tbody.insertBefore(newTr, refRow.nextSibling);
                    else tbody.appendChild(newTr);
                } else {
                    // Default: Append to end
                    tbody.appendChild(newTr);
                }
            }
            else if (action === 'row-del') {
                if (tbody.rows.length <= 1) return; // Don't delete last row

                if (rIdx > 0) {
                    table.deleteRow(rIdx);
                    // If we deleted the active row, reset context
                    resetTableControls(wrapper);
                } else {
                    // Default: Delete last row
                    tbody.deleteRow(tbody.rows.length - 1);
                }
            }

            // --- COLUMN OPERATIONS ---
            else if (action === 'col-add') {
                // Determine insertion index (after current, or at end)
                // If cIdx is -1, insert at end. If cIdx exists, insert at cIdx + 1
                const insertIdx = (cIdx !== -1) ? cIdx + 1 : -1;

                // Header
                const th = document.createElement('th'); th.innerText = "Header";
                insertIntoRow(thead.rows[0], th, insertIdx);

                // Body
                for(let row of tbody.rows) {
                    const td = document.createElement('td'); td.innerText = "Cell";
                    insertIntoRow(row, td, insertIdx);
                }
            }
            else if (action === 'col-del') {
                const row0 = thead.rows[0];
                if (row0.cells.length <= 1) return; // Don't delete last col

                const deleteIdx = (cIdx !== -1) ? cIdx : -1; // Delete specific or last

                // Helper to safely delete
                const safeDelete = (row, idx) => {
                    if (idx === -1) row.deleteCell(-1);
                    else if (row.cells[idx]) row.deleteCell(idx);
                };

                safeDelete(thead.rows[0], deleteIdx);
                for(let row of tbody.rows) safeDelete(row, deleteIdx);
                
                if (deleteIdx !== -1) resetTableControls(wrapper);
            }
            
            saveToLocal();
        }

        // Helper for column insertion
        function insertIntoRow(row, cell, idx) {
            if (idx === -1 || idx >= row.cells.length) row.appendChild(cell);
            else row.insertBefore(cell, row.cells[idx]);
        }

        function processTableBlock(lines) {
            // Remove the separator line (e.g., |---|---|)
            const dataLines = lines.filter(l => !l.includes('---'));
            
            if (dataLines.length === 0) return;

            const wrapper = document.createElement('div');
            wrapper.className = 'table-wrapper';
            wrapper.contentEditable = "false";

            // 1. Add Delete Table Button
            attachBlockControls(wrapper);

            // 2. Add Row Controls (Y-axis)
            const controlsY = document.createElement('div');
            controlsY.className = 'table-controls-y';
            controlsY.contentEditable = "false";
            controlsY.innerHTML = `
                <button class="btn-mini-control" onclick="modifyTable(this, 'row-add')" title="Insert Row Below"><i class="ph ph-arrow-down"></i></button>
                <button class="btn-mini-control danger" onclick="modifyTable(this, 'row-del')" title="Delete Row"><i class="ph ph-trash"></i></button>
            `;

            // 3. Add Col Controls (X-axis)
            const controlsX = document.createElement('div');
            controlsX.className = 'table-controls-x';
            controlsX.contentEditable = "false";
            controlsX.innerHTML = `
                <button class="btn-mini-control" onclick="modifyTable(this, 'col-add')" title="Insert Column Right"><i class="ph ph-arrow-right"></i></button>
                <button class="btn-mini-control danger" onclick="modifyTable(this, 'col-del')" title="Delete Column"><i class="ph ph-trash"></i></button>
            `;

            wrapper.appendChild(controlsY);
            wrapper.appendChild(controlsX);

            const table = document.createElement('table');
            table.contentEditable = "true";
            
            // Process Header (First line)
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            const headers = dataLines[0].split('|').filter(c => c.trim() !== '').map(c => c.trim());
            
            headers.forEach(text => {
                const th = document.createElement('th');
                th.innerText = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            // Process Body (Rest of lines)
            const tbody = document.createElement('tbody');
            for (let i = 1; i < dataLines.length; i++) {
                const tr = document.createElement('tr');
                const cells = dataLines[i].split('|').filter(c => c.trim() !== '').map(c => c.trim());
                
                // Ensure row has same cols as header
                for(let j=0; j<headers.length; j++) {
                    const td = document.createElement('td');
                    td.innerText = cells[j] || "";
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }
            table.appendChild(tbody);
            
            wrapper.appendChild(table);
            editor.appendChild(wrapper);
            editor.appendChild(document.createElement('p')); // Spacing
        }

        // --- INLINE LINK LOGIC ---

        // 1. Open the Modal
        function openLinkModal() {
            // Capture the current selection so we can restore it later
            saveSelection();
            
            // Get currently selected text to pre-fill the input
            const s = window.getSelection();
            const selectedText = (!s.isCollapsed) ? s.toString() : "";

            const content = `
                <div class="builder-row" style="margin-bottom:10px;">
                    <input type="text" class="glass-input" id="dynLinkText" placeholder="Link Text" value="${selectedText}">
                </div>
                <div class="builder-row">
                    <input type="text" class="glass-input" id="dynLinkUrl" placeholder="URL (https://...)" autofocus>
                </div>
            `;

            // Spawn the generic modal
            const modal = spawnModal('Insert Link', content, (overlay) => {
                const text = overlay.querySelector('#dynLinkText').value || "link";
                let url = overlay.querySelector('#dynLinkUrl').value;

                if (url) {
                    // Basic URL protocol fix
                    if (!url.startsWith('http') && !url.startsWith('#') && !url.startsWith('/')) {
                        url = 'https://' + url;
                    }
                    insertInlineLink(text, url);
                    return true; // Close modal
                }
                return false; // Keep open if invalid
            });
            
            // Focus the URL input automatically
            setTimeout(() => {
                const urlInput = modal.querySelector('#dynLinkUrl');
                if(urlInput) urlInput.focus();
            }, 50);
        }

        // 2. Insert the Link (Strictly Inline)
        function insertInlineLink(text, url) {
            restoreSelection(); // Put cursor back exactly where it was
            
            // Create the anchor element
            const a = document.createElement('a');
            a.href = url;
            a.target = "_blank";
            a.textContent = text;
            a.contentEditable = "false"; // Makes it behave like a solid unit (optional, usually better "true" for editing text)
            // Actually, for easy editing, let's keep it true but style it:
            a.contentEditable = "true"; 
            
            // We use execCommand 'insertHTML' because it handles replacing the selection perfectly
            // and keeps the flow inline (doesn't break paragraphs).
            const html = `<a href="${url}" target="_blank">${text}</a>`;
            document.execCommand('insertHTML', false, html);
            
            // Trigger Save
            saveToLocal(false);
        }

        function closeLinkModal() {
            document.getElementById('linkModal').classList.remove('active');
        }

        function confirmInsertLink() {
            const text = document.getElementById('linkTextInput').value || "link";
            const url = document.getElementById('linkUrlInput').value;
            
            if (url) {
                restoreSelection(); // Put cursor back
                
                // Use execCommand to insert HTML. This ensures it plays nice with bold/italic
                const html = `<a href="${url}" target="_blank" contenteditable="false">${text}</a>`;
                document.execCommand('insertHTML', false, html);
                
                // Move cursor after the link (hacky fix for Chrome)
                const s = window.getSelection();
                s.collapseToEnd(); 
            }
            closeLinkModal();
        }

        function createTaskItem(text, isChecked = false) {
            const li = document.createElement('li');
            li.className = 'task-item';
            
            // Custom Checkbox Div (Not a real input, easier to style/control)
            const checkbox = document.createElement('div');
            checkbox.className = isChecked ? 'task-checkbox checked' : 'task-checkbox';
            checkbox.contentEditable = "false";
            
            // Click event to toggle
            checkbox.onclick = function(e) {
                // e.stopPropagation() prevents caret moving weirdly
                e.stopPropagation(); 
                this.classList.toggle('checked');
                saveToLocal(); // Save state immediately
            };
            
            // The text content
            const span = document.createElement('span');
            span.contentEditable = "true";
            span.innerText = text;
            
            li.appendChild(checkbox);
            li.appendChild(span);
            return li;
        }

        // --- NEW: Native Task List Logic ---
        function insertTaskList() {
            document.execCommand('insertUnorderedList');
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            let node = selection.anchorNode;
            while (node && node.tagName !== 'UL' && node !== editor) {
                node = node.parentElement;
            }
            
            if (node && node.tagName === 'UL') {
                node.classList.add('task-list');
                node.querySelectorAll('li').forEach(li => li.removeAttribute('style'));
            }
            editor.focus();
        }
        // --- Handle Checkbox Clicks ---
        // We detect if the user clicked the "::before" pseudo-element by checking coordinates
        editor.addEventListener('mousedown', function(e) {
            if (e.target.tagName === 'LI') {
                const parent = e.target.parentElement;
                if (parent && parent.classList.contains('task-list')) {
                    // Check if click is in the "bullet zone" (left of the text)
                    // The checkbox is positioned absolute at left: -25px
                    const rect = e.target.getBoundingClientRect();
                    const clickX = e.clientX - rect.left; // X position relative to the LI text start
                    
                    // If click is to the left of the text (where the box is)
                    if (clickX < 0) {
                        e.preventDefault(); // Prevent moving cursor
                        e.target.classList.toggle('checked');
                        saveToLocal();
                    }
                }
            }
        });

        // --- Ensure New Lines aren't Checked by Default ---
        editor.addEventListener('keyup', function(e) {
            if (e.key === 'Enter') {
                const selection = window.getSelection();
                const node = selection.anchorNode;
                // If inside a task list, remove 'checked' from the new empty line
                let li = node;
                while(li && li.tagName !== 'LI') li = li.parentElement;
                
                if (li && li.parentElement.classList.contains('task-list')) {
                    // If the new line is empty, uncheck it (browsers clone the class on Enter)
                    if (li.innerText.trim() === '') {
                        li.classList.remove('checked');
                    }
                }
            }
        });

        function hydrateDOM() {
            // 1. Re-attach Drag Events to existing Block Handles
            document.querySelectorAll('.drag-handle').forEach(handle => {
                const wrapper = handle.parentElement;
                // Clone node to strip old (broken) listeners if any, implies fresh start
                // Actually, since innerHTML was just set, there are NO listeners. Just add them.
                handle.draggable = true;
                handle.addEventListener('dragstart', (e) => {
                    e.stopPropagation();
                    handleDragStart(e, wrapper);
                });
            });

            // 2. Re-attach Drag to Images (Directly draggable ones)
            document.querySelectorAll('img').forEach(img => {
                // Only if not inside a wrapper (Legacy check)
                if(!img.parentElement.classList.contains('visual-block-wrapper')) {
                    makeDraggable(img);
                }
            });

            // 3. Re-initialize Mermaid
            try { mermaid.run({ nodes: document.querySelectorAll('.mermaid') }); } catch(e){}

            // 4. Re-initialize Charts
            document.querySelectorAll('.chart-wrapper').forEach(wrapper => {
                const canvas = wrapper.querySelector('canvas');
                if (canvas && wrapper.dataset.export) {
                    try {
                        const existingChart = Chart.getChart(canvas);
                        if (existingChart) existingChart.destroy();
                        const config = JSON.parse(wrapper.dataset.export);
                        new Chart(canvas, config);
                    } catch (e) {}
                }
            });
        }

        function spawnModal(title, contentHTML, onConfirm) {
            toggleScrollLock(true);
            // Remove existing if any (cleanup)
            const existing = document.getElementById('dynamicModal');
            if(existing) existing.remove();

            const overlay = document.createElement('div');
            overlay.id = 'dynamicModal';
            overlay.className = 'modal-overlay';
            
            overlay.innerHTML = `
                <div class="modal">
                    <h3>${title}</h3>
                    ${contentHTML}
                    <div class="modal-actions">
                        <button class="btn-glass btn-glass-cancel" id="dynCancel">Cancel</button>
                        <button class="btn-glass btn-glass-insert active" id="dynConfirm">Insert</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // Event Listeners
            const btnCancel = overlay.querySelector('#dynCancel');
            const btnConfirm = overlay.querySelector('#dynConfirm');

            const close = () => {
                overlay.classList.remove('active');
                toggleScrollLock(false); // UNLOCK
                setTimeout(() => overlay.remove(), 300);
            };

            btnCancel.onclick = close;
            
            btnConfirm.onclick = () => {
                if(onConfirm(overlay)) close();
            };

            // Inputs Enter Key support
            const inputs = overlay.querySelectorAll('input');
            inputs.forEach(input => {
                input.addEventListener('keyup', (e) => {
                    if(e.key === 'Enter') btnConfirm.click();
                    if(e.key === 'Escape') close();
                });
            });

            // Trigger Reflow and Show
            setTimeout(() => overlay.classList.add('active'), 10);
            return overlay; // Return in case specific focus is needed
        }
        // --- 1. COPY & CUT HANDLERS ---
        document.addEventListener('copy', (e) => {
            if (setClipboardData(e)) {
                e.preventDefault(); // Hijack only if we successfully captured data
            }
        });

        document.addEventListener('cut', (e) => {
            if (setClipboardData(e)) {
                e.preventDefault();
                // Execute delete after copying data
                document.execCommand('delete'); 
                saveToLocal();
            }
        });

        editor.addEventListener('paste', (e) => {
            e.preventDefault();

            // A. Handle Files (Images)
            if (e.clipboardData.files && e.clipboardData.files.length > 0) {
                const file = e.clipboardData.files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        insertImageTag(evt.target.result);
                        saveToLocal(true);
                    };
                    reader.readAsDataURL(file);
                }
                return;
            }

            // B. Get Content
            const html = e.clipboardData.getData('text/html');
            const text = e.clipboardData.getData('text/plain');

            if (!html) {
                // Fallback for plain text
                document.execCommand('insertText', false, text);
                saveToLocal(false);
                return;
            }

            // C. Analyze Source
            const isInternal = html.includes('<meta name="md-edit-source" content="internal">');
            const isShiftPressed = e.shiftKey; // Detect Ctrl+Shift+V

            // D. Process HTML
            const cleanHTML = processPaste(html, isInternal, isShiftPressed);

            // E. Insert
            // insertHTML handles block splitting (e.g. pasting <h1> inside <h1> will split it)
            document.execCommand('insertHTML', false, cleanHTML);
            saveToLocal(false);
        });

        function processPaste(htmlString, isInternal, isShiftPressed) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(htmlString, 'text/html');
            const body = doc.body;

            // List of classes that define our Special Blocks
            const BLOCK_CLASSES = [
                'visual-block-wrapper', 
                'math-wrapper', 
                'code-block-wrapper', 
                'quote-wrapper',
                'table-wrapper',
                'markscheme',
                'block-container' // Math block container
            ];

            const walk = (node) => {
                if (node.nodeType !== 1) return; // Skip text nodes

                // 1. Identify Special Blocks
                const isSpecialBlock = BLOCK_CLASSES.some(cls => node.classList.contains(cls));
                const tagName = node.tagName.toLowerCase();

                // 2. Handling Special Blocks (Images, Graphs, Math)
                if (isSpecialBlock) {
                    // ALWAYS preserve these, even on Shift+V
                    // Ensure contentEditable is correct (browsers sometimes strip it)
                    if (node.classList.contains('visual-block-wrapper') || 
                        node.classList.contains('code-block-wrapper') ||
                        node.classList.contains('block-container')) {
                        node.contentEditable = "false";
                    }
                    
                    // Allow children of special blocks to remain untouched (don't strip inside Desmos/Charts)
                    return; 
                }

                // 3. Handling Headers & Structure
                if (isShiftPressed) {
                    // Ctrl+Shift+V: "Align with location format"
                    // Strategy: Flatten Headers/Lists into Paragraphs, strip styles, BUT keep Images.
                    
                    // If it's a Header, convert to P
                    if (/^h[1-6]$/.test(tagName)) {
                        const p = document.createElement('p');
                        p.innerHTML = node.innerHTML;
                        node.replaceWith(p);
                        node = p; // Update reference
                    }
                    // Strip inline formatting (b, i, u, span)
                    // We do this by unwrapping, unless it holds a special block
                    if (['b','strong','i','em','u','span','font'].includes(tagName)) {
                        // If it doesn't contain a special block, unwrap it
                        if (!node.querySelector(BLOCK_CLASSES.map(c=>'.'+c).join(','))) {
                            // Using outerHTML replaces the tag with its children
                            // We need a helper for unwrapping to be safe, but simple approach:
                            // node.replaceWith(...node.childNodes) works in modern browsers
                            // We'll just strip attributes to be safe and "align format"
                            node.removeAttribute('style');
                            node.removeAttribute('class');
                            // Actually, Shift+V usually means PLAIN text. 
                            // To "Align Format", we effectively remove the tag but keep text.
                            // But user said "keep images".
                            // So we strip attributes.
                        }
                    }
                } 
                else if (isInternal) {
                    // Ctrl+V (Internal): Trust the structure fully.
                    // Just ensure no garbage styles crept in.
                    // We usually don't need to do anything if it's internal.
                } 
                else {
                    // Ctrl+V (External): Keep Headers, but strip Word/Web garbage.
                    node.removeAttribute('style'); // Kill colors/fonts
                    node.removeAttribute('class'); // Kill 'MsoNormal', etc.
                    node.removeAttribute('id');
                    node.removeAttribute('align');
                }

                // 4. Cleanup Empty Spans (Common in copy-paste)
                if (tagName === 'span' && node.attributes.length === 0 && !node.classList.length) {
                    // Unwrap
                    const parent = node.parentNode;
                    while(node.firstChild) parent.insertBefore(node.firstChild, node);
                    parent.removeChild(node);
                    return; // Node is gone, stop processing it
                }

                // Recurse
                Array.from(node.children).forEach(walk);
            };

            Array.from(body.children).forEach(walk);

            return body.innerHTML;
        }

        // --- Helper: Prepare Clipboard/Drag Data ---
        // Wraps selection in <div> and adds "internal" signature
        let internalDragRange = null; // Store source range for Drag-Move

        function setClipboardData(e, isDrag = false) {
            const selection = window.getSelection();
            if (!editor.contains(selection.anchorNode) || selection.isCollapsed) return false;

            // Store range for "Cut" behavior during Drag & Drop
            if (isDrag) {
                internalDragRange = selection.getRangeAt(0).cloneRange();
            }

            // Clone content
            const userSelection = selection.getRangeAt(0).cloneContents();
            const div = document.createElement('div');
            div.appendChild(userSelection);

            // Signature
            const signature = '<meta name="md-edit-source" content="internal">';
            
            // Set Data
            if (e.clipboardData) {
                e.clipboardData.setData('text/html', signature + div.innerHTML);
                e.clipboardData.setData('text/plain', selection.toString());
            } else if (e.dataTransfer) {
                e.dataTransfer.setData('text/html', signature + div.innerHTML);
                e.dataTransfer.setData('text/plain', selection.toString());
                e.dataTransfer.effectAllowed = isDrag ? 'move' : 'copy';
            }
            return true;
        }

        function toggleScrollLock(isActive) {
            document.body.classList.toggle('modal-open', isActive);
        }
        </script>
</body>
</html>

